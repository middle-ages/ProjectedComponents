{"version":3,"sources":["font/index.ts","font/metrics/horizontal.ts","font/metrics/vertical.ts","font/manager.ts","css/border/constants.ts","css/lib.ts","component/ThreeD/Box/types.ts","component/ThreeD/Box/colors.ts","geometry/Axis.ts","geometry/Point.ts","component/ThreeD/Box/Face.tsx","component/TwoD/At.tsx","component/TwoD/Flex.tsx","component/TwoD/Text/Baseline.tsx","component/TwoD/Text/PlainText.tsx","component/TwoD/Text/MetricText.tsx","component/TwoD/Text/index.tsx","component/TwoD/Labeled.tsx","component/ThreeD/Box/component.tsx","component/TwoD/Panel.tsx","component/ThreeD/LabeledBox.tsx","component/ThreeD/LabeledTextBox.tsx","component/ThreeD/Tower.tsx","component/Demos.tsx","component/Source.tsx","component/Stage.tsx","component/Scene.tsx","component/Viewport/camera.ts","component/Viewport/orbit.ts","component/Viewport/index.tsx","component/App.tsx","index.tsx","css/index.ts","css/border/index.ts","css/builders.ts","css/grid.ts","util/Any.ts","util/Object.ts","util/Tuple.ts","font/useFontMetrics.ts","font/loader/styleSheet.ts","font/loader/loadLocal.ts","font/loader/index.ts","css/util.ts","font/loader/loadRemote.ts"],"names":["defaultMeasured","fontFamily","fontSize","text","hPad","measuredKeys","Object","keys","mergeDefaultMeasured","mergeDefined","splitMeasured","split","fallbackFontSize","measured","measureText","font","userMeasured","unitsPerEm","advanceWidth","bbox","minX","maxX","layout","uemToPx","flow","multiply","divide","textWidth","pipe","textIndent","bearingRight","recMap","DefaultLineHeightEm","readOs2","computeWinBaseLine","lineHeight","lineGap","uem","winDescent","winAscent","computeTypoBaseLine","typoAscender","typoLineGap","typoDescender","FontManager","constructor","loadedFonts","cache","Map","get","family","defined","Error","res","this","size","families","map","f","join","measure","computeBaseLine","fromTypoMetrics","baseline","forEach","loadedFont","set","Array","from","values","fonts","async","BorderEdges","none","all","top","right","bottom","left","leftRight","noBottom","noTop","topBottom","PadDirMultiplier","both","HorizontalPadEdges","VerticalPadEdges","atomic","relative","position","absolute","borderBox","boxSizing","contentBox","w100","width","h100","height","minContentWidth","hFlex","display","flexDirection","vFlex","flex1","flex","flexWrap","alignBaseline","alignItems","alignTop","stretch","noOverflow","overflow","autoOverflow","noWrap","whiteSpace","whiteBg","background","greyBg","transparentBg","blackBorder","border","rotateIsometric","transform","rotateInvIsometric","centerOrigin","transformOrigin","topLeftOrigin","preserveThreed","transformStyle","play","animationPlayState","pause","composed","wh100","absWh100","bwBorder","isometric","css","cssOf","REC","style","mergeN","picks","ThreeDFaces","Faces","fromTuple","colors","RE","fromEntries","mapColors","idx","BoxThemes","primary","grayscale","i","Math","round","transparent","white","yellowOrange","boxThemeStyle","key","face","boxThemeColor","backgroundColor","Axis","isX","curry2","eqString","equals","isY","isZ","match","axis","x","y","z","hasDefined","splitPoint","defaultBoxDef","depth","boxThemeKey","opacity","boxDefKeys","mergeDefaultBoxDef","splitBoxDef","defaultBoxFace","defaultEdgeDef","mergeDefaultBoxFace","faceTransforms","back","borderWidth","shift","borderPad","depthPx","borderPadPx","RA","pxValue","translate","allButBorders","rotateBy","faceStyle","args","borderDef","styles","allBordersCss","BoxFace","children","props","className","At","point","borderCss","Flex","dir","gap","wrap","flexGap","padding","maybePxValue","HFlex","VFlex","defaultCss","baselineBorder","borderColor","borderStyle","borderEdges","Baseline","hPx","useFontBaseline","PlainText","rest","splitBorderDef","textDef","textStyle","useTextBoxMetrics","MetricText","textKeys","splitText","Text","showMetrics","TextTag","Labeled","labelColor","labelBgColor","labelOpacity","isThreeD","edgeDef","noEdge","splitEdgeDef","userTextProps","textProps","labelStyles","foregroundColor","topRightBorderRadius","threeDStyle","borderFor","addBorderEdges","Box","commonFaceProps","LabeledBox","zLevel","userEdgeDef","noEdgeDef","noPoint","userBoxDef","labeled","mergeDefaultEdgeDef","edgeProps","boxDef","boxProps","labeledProps","px","LabeledTextBox","labelText","noText","leaf","curryFn","common","link","textField","fontPicker","plainText","labeledText","hello","demos","name","component","decode","reactElementToJSXString","componentSourceStyles","Source","language","filterProps","ComponentSource","Stage","Scene","grid","gridBackground","IsoScene","cameras","front","angle","iso","invIso","iso45","invIso45","frontTopLeft","frontTopRight","frontBottomLeft","frontBottomRight","cameraKeyAngle","camera","invAngle3","orbit","inverseOrbitKey","value","includes","invAngle","orbitAnimation","keyframes","rotate","to","Viewport","scale","isOrbiting","periodSec","perspective","animationName","keyframeStyle","animation","playStyle","animationStyles","viewWidth","viewHeight","rootClassName","App","strokeWidth","withFontManager","fontManager","ReactDOM","render","Provider","document","getElementById","defaultBorderDef","edgeDefKeys","borderDefKeys","mergeDefaultBorderDef","hasBorder","edgeList","edge","ucFirst","k","v","deg","abs","sign","hPadding","pad","paddingLeft","paddingRight","pxRecord","color","emLineHeight","h","emValue","borderTopRightRadius","animationDuration","animationIterationCount","animationTimingFunction","defaultConfig","majorStep","colorStop","config","orthoLines","halfStroke","repeatingLinearGradient","parallelLines","backgroundAttachment","backgroundSize","square","undefined","o","objects","assign","filterUndefValues","unfiltered","not","reject","first","withKeys","filter","restKeys","without","FontContext","createContext","useFontContext","useContext","Lens","fromProps","parser","Parser","cleanUrl","url","replace","cleanFamily","declarationToEntry","d","ruleToFetchFont","cssText","declarations","parse","rules","rulelist","parseExpressions","AR","isFontFaceRule","rule","type","sheetToFonts","styleSheet","window","styleSheets","loadFont","Promise","bind","then","s","charAt","toUpperCase","slice","isNaN","entries","head","tail","raw","fetch","request","src","blob","buffer","resolve","reader","FileReader","onload","Buffer","result","onerror","readAsArrayBuffer","readArrayBuffer","fontkit","create","e","message"],"mappings":"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","file":"static/js/main.5bfa353c.chunk.js","sourcesContent":["export * from 'src/font/loader';\nexport * from 'src/font/manager';\nexport * from 'src/font/metrics';\nexport * from 'src/font/types';\nexport * from 'src/font/useFontMetrics';\n","import { Font } from '@pdf-lib/fontkit';\nimport { divide, multiply } from 'fp-ts-std/Number';\nimport { flow, pipe } from 'fp-ts/lib/function';\nimport { map as recMap } from 'fp-ts/Record';\nimport { mergeDefined, split, ToRequired } from 'src/util';\n\n/**\n * A string of text to be measured in a font size/family with given\n * horizontal padding and horizontal border width.\n */\nexport interface Measured {\n  fontFamily: string;\n  fontSize: number;\n  text: string;\n  hPad: number;\n}\n\nexport type MeasuredKey = keyof Measured;\n\nexport interface NumericHMetrics {\n  advanceWidth: number;\n  textWidth: number;\n  minX: number;\n  maxX: number;\n  textIndent: number;\n  bearingRight: number;\n}\n\nexport type HMetrics = Measured & NumericHMetrics;\n\nexport const defaultMeasured: Measured = {\n    fontFamily: 'Roboto',\n    fontSize: 16,\n    text: ' ',\n    hPad: 6,\n  },\n  measuredKeys = Object.keys(defaultMeasured) as MeasuredKey[],\n  mergeDefaultMeasured: ToRequired<Partial<Measured>> = mergeDefined(\n    defaultMeasured,\n  ),\n  splitMeasured = split(measuredKeys);\n\nexport const fallbackFontSize = (fontSize: number) => (\n  measured: Partial<Measured>,\n) => ({ fontSize, ...measured } as Partial<Measured> & { fontSize: number });\n\nexport const measureText = (font: Font) => (\n  userMeasured: Partial<Measured> = {},\n): HMetrics => {\n  const measured = mergeDefined(defaultMeasured)(userMeasured),\n    { fontSize, text } = measured,\n    { unitsPerEm } = font,\n    {\n      advanceWidth,\n      bbox: { minX, maxX },\n    } = font.layout(text),\n    uemToPx = flow(multiply(fontSize), divide(unitsPerEm)),\n    textWidth = maxX - minX;\n\n  return {\n    ...measured,\n    ...pipe(\n      {\n        advanceWidth,\n        textWidth,\n        minX,\n        maxX,\n        textIndent: -1 * minX,\n        bearingRight: advanceWidth - textWidth,\n      },\n      recMap(uemToPx),\n    ),\n  };\n};\n","import { Font } from '@pdf-lib/fontkit';\n\nexport const DefaultLineHeightEm = 1.5;\n\nconst Os2Keys = [\n  'typoAscender',\n  'typoDescender',\n  'typoLineGap',\n  'winDescent',\n  'winAscent',\n] as const;\n\ntype Os2Data = Record<typeof Os2Keys[number], number>;\n\n/** Fontkit typescript declarations are missing these. */\ndeclare module '@pdf-lib/fontkit' {\n  export interface Font {\n    os2: Os2Data;\n  }\n}\n\nconst readOs2 = (font: Font): Os2Data => font['OS/2'] as any;\n\nexport const computeWinBaseLine = (\n  font: Font,\n  fontSize: number,\n  lineHeight = DefaultLineHeightEm,\n): number => {\n  const { lineGap, unitsPerEm: uem } = font,\n    { winDescent, winAscent } = readOs2(font);\n  return (lineHeight * uem + winAscent + lineGap - winDescent) / 2;\n};\n\nexport const computeTypoBaseLine = (\n  font: Font,\n  fontSize: number,\n  lineHeight = DefaultLineHeightEm,\n): number => {\n  const { unitsPerEm: uem } = font,\n    { typoAscender, typoLineGap, typoDescender } = readOs2(font);\n  return (lineHeight * uem + typoAscender + typoLineGap + typoDescender) / 2;\n};\n","import { Font } from '@pdf-lib/fontkit';\nimport { defined } from 'src/util';\nimport {\n  computeTypoBaseLine,\n  computeWinBaseLine,\n  HMetrics,\n  Measured,\n  measureText,\n} from 'src/font/metrics';\nimport { FetchedFont } from 'src/font/types';\n\nexport class FontManager {\n  private cache: Map<string, FetchedFont> = new Map();\n\n  constructor(...loadedFonts: FetchedFont[]) {\n    loadedFonts.forEach(loadedFont => {\n      this.cache.set(loadedFont.fontFamily, loadedFont);\n    });\n  }\n\n  get = (family: string): Font => {\n    if (!defined(family))\n      throw new Error('Requested font but family name is undefined.');\n    const res = this.cache.get(family);\n    if (!defined(res))\n      throw new Error(\n        `No font found for family name “${family}”. ` +\n          (this.cache.size\n            ? `These families have been loaded: ${this.families\n                .map(f => `“${f}”`)\n                .join(', ')}`\n            : 'No font families have been loaded.'),\n      );\n    return res.font;\n  };\n\n  get fonts(): FetchedFont[] {\n    return Array.from(this.cache.values());\n  }\n\n  get families(): string[] {\n    return this.fonts.map(f => f.fontFamily);\n  }\n\n  measure = (measured: Measured): HMetrics =>\n    measureText(this.get(measured.fontFamily))(measured);\n\n  computeBaseLine = (\n    fontFamily: string,\n    fontSize: number,\n    fromTypoMetrics = false,\n  ): number => {\n    const font = this.get(fontFamily),\n      baseline = (fromTypoMetrics ? computeTypoBaseLine : computeWinBaseLine)(\n        font,\n        fontSize,\n      );\n\n    return (fontSize / font.unitsPerEm) * baseline;\n  };\n\n  static from = async (\n    loadedFonts: Promise<FetchedFont[]>,\n  ): Promise<FontManager> => new FontManager(...(await loadedFonts));\n}\n","export const LineStyles = [\n  'dashed',\n  'dotted',\n  'double',\n  'groove',\n  'hidden',\n  'inset',\n  'none',\n  'outset',\n  'ridge',\n  'solid',\n] as const;\n\nexport const BorderDirs = ['top', 'bottom', 'left', 'right'] as const;\n\nexport const BorderEdges = {\n  none: [],\n  all: ['top', 'bottom', 'left', 'right'],\n  top: ['top'],\n  right: ['right'],\n  bottom: ['bottom'],\n  left: ['left'],\n  leftRight: ['left', 'right'],\n  noBottom: ['top', 'left', 'right'],\n  noTop: ['bottom', 'left', 'right'],\n  topBottom: ['bottom', 'top'],\n} as const;\n\nexport type HPadDir = 'left' | 'right' | 'both' | 'none';\nexport type VPadDir = 'top' | 'bottom' | 'both' | 'none';\n\nexport const PadDirMultiplier: Record<HPadDir | VPadDir, number> = {\n  left: 1,\n  right: 1,\n  top: 1,\n  bottom: 1,\n  both: 2,\n  none: 0,\n};\n\nexport const HorizontalPadEdges: Record<keyof typeof BorderEdges, HPadDir> = {\n  none: 'none',\n  all: 'both',\n  top: 'none',\n  right: 'right',\n  bottom: 'none',\n  left: 'left',\n  leftRight: 'both',\n  noBottom: 'both',\n  noTop: 'both',\n  topBottom: 'none',\n};\n\nexport const VerticalPadEdges: Record<keyof typeof BorderEdges, VPadDir> = {\n  none: 'none',\n  all: 'both',\n  top: 'top',\n  right: 'none',\n  bottom: 'bottom',\n  left: 'none',\n  leftRight: 'none',\n  noBottom: 'top',\n  noTop: 'bottom',\n  topBottom: 'both',\n};\n","import { pipe } from 'fp-ts/lib/function';\nimport * as REC from 'fp-ts/Record';\nimport { style } from 'typestyle';\nimport { mergeN, picks } from 'src/util';\nimport { Style } from 'src/css/types';\n\nconst atomic = {\n  relative: { position: 'relative' },\n  absolute: { position: 'absolute', top: 0, left: 0 },\n  borderBox: { boxSizing: 'border-box' },\n  contentBox: { boxSizing: 'content-box' },\n\n  w100: { width: '100%' },\n  h100: { height: '100%' },\n  minContentWidth: { width: 'min-content' },\n\n  hFlex: { display: 'flex', flexDirection: 'row' },\n  vFlex: { display: 'flex', flexDirection: 'column' },\n  flex1: { flex: 1 },\n  flexWrap: { flexWrap: 'wrap' },\n  alignBaseline: { alignItems: 'baseline' },\n  alignTop: { alignItems: 'top' },\n  stretch: { alignItems: 'stretch' },\n\n  noOverflow: { overflow: 'hidden' },\n  autoOverflow: { overflow: 'auto' },\n  noWrap: { whiteSpace: 'nowrap' },\n\n  whiteBg: { background: 'white' },\n  greyBg: { background: 'grey' },\n  transparentBg: { background: 'transparent' },\n\n  blackBorder: { border: '1px solid black' },\n\n  rotateIsometric: {\n    transform: 'rotateX(-30deg) rotateY(30deg) rotateZ(0deg)',\n  },\n  rotateInvIsometric: {\n    transform: 'rotateX(330deg) rotateY(30deg) rotateZ(0deg)',\n  },\n  centerOrigin: { transformOrigin: 'center' },\n  topLeftOrigin: { transformOrigin: 'top left' },\n  preserveThreed: { transformStyle: 'preserve-3d' },\n\n  play: { animationPlayState: 'running' },\n  pause: { animationPlayState: 'paused' },\n} as const;\n\nexport const composed = {\n  wh100: { ...atomic.w100, ...atomic.h100 },\n  absWh100: { ...atomic.w100, ...atomic.h100, ...atomic.absolute },\n\n  bwBorder: { ...atomic.whiteBg, ...atomic.blackBorder },\n\n  isometric: {\n    ...atomic.rotateIsometric,\n    ...atomic.preserveThreed,\n  },\n} as const;\n\nexport const css = { ...atomic, ...composed } as const,\n  cssClasses: Record<StyleKey, string> = REC.map(style)(css);\n\nexport type Css = typeof css;\n\nexport const cssOf = <K extends StyleKey>(...keys: K[]): Style =>\n    mergeN(...pipe(css, picks(...keys), Object.values)),\n  cssClassOf = <K extends StyleKey>(key: K): string => cssClasses[key];\n\nexport type Styles = typeof css;\nexport type StyleKey = keyof Styles;\n","export type ThreeDFace = typeof ThreeDFaces[number];\n\nexport type Face = 'front' | ThreeDFace;\n\nexport const ThreeDFaces = ['back', 'top', 'bottom', 'left', 'right'] as const,\n  Faces = ['front', ...ThreeDFaces] as Face[];\n","import { pipe } from 'fp-ts/lib/function';\nimport * as RE from 'fp-ts/ReadonlyArray';\nimport { backgroundColor, Color, Style } from 'src/css';\nimport { Face, Faces } from 'src/component/ThreeD/Box/types';\n\nexport type BoxTheme = Record<Face, Color>;\nexport type BoxThemes = typeof BoxThemes;\nexport type BoxThemeKey = keyof BoxThemes;\n\ntype BoxColors = [Color, Color, Color, Color, Color, Color];\ntype FaceNum = 0 | 1 | 2 | 3 | 4 | 5;\n\nconst fromTuple = (colors: BoxColors) =>\n    pipe(Faces, RE.zip(colors), Object.fromEntries) as BoxTheme,\n  mapColors = (f: (idx: FaceNum) => Color) =>\n    fromTuple(\n      pipe(\n        RE.range(0, 5),\n        RE.map(idx => f(idx as FaceNum)),\n      ) as BoxColors,\n    );\n\nconst idxToPercent = (idx: number) => Math.round((100 * (6 - idx)) / 6);\n\nconst BoxThemes = {\n  primary: fromTuple(['white', 'purple', 'orange', 'green', 'red', 'yellow']),\n  grayscale: mapColors(i => `hsl(0deg,0%,${idxToPercent(i)}%)`),\n  transparent: mapColors(() => 'transparent'),\n  white: mapColors(() => 'white'),\n  yellowOrange: mapColors(i => (i === 0 ? '#ffff0088' : '#ffcc0088')),\n} as const;\n\nexport const boxThemes = Object.keys(BoxThemes) as BoxThemeKey[],\n  boxThemeColor = (key: BoxThemeKey) => (face: Face): Color =>\n    BoxThemes[key][face],\n  boxThemeStyle = (key: BoxThemeKey, face: Face): Style =>\n    pipe(face, boxThemeColor(key), backgroundColor);\n","import { curry2 } from 'fp-ts-std/Function';\nimport { eqString } from 'fp-ts/lib/Eq';\n\nexport type TwoDAxis = 'x' | 'y';\nexport type ThreeDAxis = 'x' | 'y' | 'z';\nexport type TwoDRecord<T> = Record<TwoDAxis, T>;\nexport type ThreeDRecord<T> = Record<ThreeDAxis, T>;\n\nexport type Angle3 = Partial<ThreeDRecord<number>>;\n\nexport const Axis = {\n  isX: curry2(eqString.equals)('x'),\n  isY: curry2(eqString.equals)('y'),\n  isZ: curry2(eqString.equals)('z'),\n  match: (axis: ThreeDAxis) => <T>(x: T, y: T, z: T): T =>\n    axis === 'x' ? x : axis === 'y' ? y : z,\n} as const;\n","import { ThreeDRecord } from 'src/geometry/Axis';\nimport { defined, split } from 'src/util';\n\nexport type Point = Partial<ThreeDRecord<number | string>>;\n\nexport const hasDefined = ({ x, y, z }: Point) =>\n    defined(x) || defined(y) || defined(z),\n  splitPoint = split(['x', 'y', 'z']);\n","import * as RA from 'fp-ts/ReadonlyArray';\nimport { FC } from 'react';\nimport { BoxThemeKey, boxThemeStyle } from 'src/component/ThreeD/Box/colors';\nimport { Face, ThreeDFace } from 'src/component/ThreeD/Box/types';\nimport {\n  allBordersCss,\n  cssOf,\n  defaultEdgeDef,\n  pxValue,\n  rotateBy,\n  Style,\n  TotalEdgeDef,\n  translate,\n} from 'src/css';\nimport { Axis, ThreeDAxis } from 'src/geometry';\nimport { defined, mergeDefined, split, ToRequired } from 'src/util';\nimport { style } from 'typestyle';\n\nexport interface TotalBoxDef {\n  depth: number;\n  boxThemeKey: BoxThemeKey;\n  opacity: number;\n}\n\nexport type BoxDef = Partial<TotalBoxDef>;\nexport type BoxDefKey = keyof TotalBoxDef;\n\nexport type TotalBoxFace = TotalBoxDef & TotalEdgeDef;\nexport type BoxFace = Partial<TotalBoxFace>;\nexport type BoxFaceKey = keyof TotalBoxFace;\n\nexport const defaultBoxDef: TotalBoxDef = {\n    depth: 18,\n    boxThemeKey: 'primary',\n    opacity: 1,\n  },\n  boxDefKeys = Object.keys(defaultBoxDef) as BoxDefKey[],\n  mergeDefaultBoxDef: ToRequired<BoxDef> = mergeDefined(defaultBoxDef),\n  splitBoxDef = split(boxDefKeys);\n\nexport const defaultBoxFace: TotalBoxFace = {\n    ...defaultBoxDef,\n    ...defaultEdgeDef,\n  },\n  boxFaceKeys = Object.keys(defaultBoxFace) as BoxFaceKey[],\n  mergeDefaultBoxFace: ToRequired<BoxFace> = mergeDefined(defaultBoxFace);\n\nconst faceTransforms: Record<\n  ThreeDFace,\n  [ThreeDAxis, 'top' | 'left'] | [ThreeDAxis]\n> = {\n  back: ['z'],\n  top: ['x'],\n  bottom: ['x', 'top'],\n  left: ['y'],\n  right: ['y', 'left'],\n};\n\nconst layout = (depth: number, borderWidth: number) => (\n  face: ThreeDFace,\n): Style => {\n  const [axis, shift] = faceTransforms[face],\n    borderPad = 2 * borderWidth,\n    [depthPx, borderPadPx] = RA.ap([depth, borderPad])([pxValue]),\n    z = translate({ z: -1 * (depth + borderPad) }) + ' ',\n    allButBorders = `calc(100% - ${borderPadPx})`;\n\n  return {\n    ...cssOf('absolute', 'topLeftOrigin'),\n\n    ...{ width: Axis.isY(axis) ? depthPx : allButBorders },\n    ...{ height: Axis.isX(axis) ? depthPx : allButBorders },\n\n    transform: z + rotateBy(axis)(90 * Axis.match(axis)(1, -1, 0)),\n\n    ...(defined(shift) ? { [shift]: '100%' } : {}),\n  };\n};\n\nexport const faceStyle = ({ face, ...args }: BoxFace & { face: Face }) => {\n  const {\n      depth,\n      boxThemeKey,\n      borderWidth,\n      opacity,\n      ...borderDef\n    } = mergeDefaultBoxFace(args),\n    styles = [\n      allBordersCss({ borderWidth, ...borderDef }),\n      ...(face !== 'front'\n        ? [layout(depth, borderWidth)(face), defined(opacity) && { opacity }]\n        : []),\n    ];\n\n  return style(boxThemeStyle(boxThemeKey, face), ...styles);\n};\n\n/**\n * One of the six faces of a box.\n *\n * Face style\n * @param depth - Box size on Z-axis in pixel. The box will be drawn so that\n * the back face will appear to be extruded `depth` pixels to the back\n * @param boxThemeKey - a key from the box themes dictionary. Sets the face\n * color scheme. Default is `basic colors`\n *\n * Wireframe line style\n * @param borderColor\n * @param borderWidth\n * @param borderStyle\n */\nexport const BoxFace: FC<BoxFace & { face: Face }> = ({\n  children,\n  ...props\n}) => <div className={faceStyle(props)}>{children}</div>;\n","import { FC } from 'react';\nimport { Styled } from 'src/component/types';\nimport {\n  borderCss,\n  BorderDef,\n  EdgeDef,\n  OmitAt,\n  Style,\n  translate,\n} from 'src/css';\nimport { hasDefined, Point, splitPoint } from 'src/geometry';\nimport { style } from 'typestyle';\n\n/**\n * The props type for components that have a:\n * 1. List of styles\n * 1. 3D coordinates\n * 1. A border on the edges defined by `borderEdges`\n */\nexport type At<S extends Style = Style> = Styled<OmitAt<S>> & Point & BorderDef;\n\n/**\n * Same as `At`, except the border, if existing, is on _all_ sides.\n * `BorderedAt<S> ≡ Omit<At<S>, 'borderEdges'>`\n */\nexport type BorderedAt<S extends Style = Style> = Styled<OmitAt<S>> &\n  Point &\n  EdgeDef;\n\n/**\n * A Component placed at some `Point` with some `BorderDef`.\n *\n * Border:\n * @param borderWidth\n * @param borderStyle\n * @param borderColor\n *\n * Position:\n * @param x\n * @param y\n * @param z\n */\nexport const At: FC<At> = ({ styles = [], children, ...props }) => {\n  const [point, borderDef] = splitPoint(props);\n\n  return (\n    <div\n      className={style(\n        hasDefined(point) && { transform: translate(point) },\n        borderCss(borderDef),\n        ...styles,\n      )}\n    >\n      {children}\n    </div>\n  );\n};\n","import { FC } from 'react';\nimport { At } from 'src/component/TwoD/At';\nimport {\n  css,\n  cssOf,\n  FlexDir,\n  flexGap,\n  maybePxValue,\n  OmitDisplay,\n  Style,\n} from 'src/css';\nimport { splitPoint } from 'src/geometry';\n\nexport type FlexStyle<S extends Style = Style> = OmitDisplay<S>;\nexport type NoDirFlexStyle<S extends Style = Style> = Omit<\n  FlexStyle<S>,\n  'flexDirection'\n>;\n\nexport interface Flex<S extends Style = Style> extends At<FlexStyle<S>> {\n  gap?: number | string;\n  wrap?: boolean;\n  dir?: FlexDir;\n}\n\nexport interface NoDirFlex<S extends Style = Style>\n  extends At<NoDirFlexStyle<S>> {\n  gap?: number | string;\n  wrap?: boolean;\n}\n\n//const defaultStyle = css.minContentWidth;\n\n/** A horizontal/vertical flex container.\n *\n * Owns the style keys:\n * 1. `transform`\n * 1. `display`\n * 1. `border`\n * 1. `border(top|bottom|left|right)`\n * 1. `border(top|bottom|left|right)(style|width|color)`\n *\n * @param dir - `column` | `row` | `column-reverse` | `row-reverse`. Default is `row`\n * @param gap - flex gap in pixels. Default is zero\n */\nexport const Flex: FC<Flex> = ({\n  dir,\n  gap = '1ex',\n  wrap = false,\n  styles = [],\n  children,\n  ...props\n}) => {\n  const [point, borderDef] = splitPoint(props);\n\n  return (\n    <At\n      styles={[\n        flexGap(gap),\n        { padding: maybePxValue(gap) },\n        wrap && css.flexWrap,\n        cssOf(dir && dir === 'row' ? 'hFlex' : 'vFlex'),\n        ...styles,\n      ]}\n      {...point}\n      {...borderDef}\n    >\n      {children}\n    </At>\n  );\n};\n\nexport const HFlex: FC<NoDirFlex> = ({ children, ...props }) => (\n  <Flex dir=\"row\" {...props}>\n    {children}\n  </Flex>\n);\n\nexport const VFlex: FC<NoDirFlex> = ({ children, ...props }) => (\n  <Flex dir=\"column\" {...props}>\n    {children}\n  </Flex>\n);\n","import { FC } from 'react';\nimport { borderCss, css, defaultCss, hPx } from 'src/css';\nimport { useFontBaseline } from 'src/font';\n\nexport const className = defaultCss(css.borderBox, css.absolute, css.w100),\n  baselineBorder = {\n    borderColor: '#ff0000ff',\n    borderStyle: 'dashed',\n    borderEdges: 'bottom',\n  } as const;\n\nexport interface Baseline {\n  fontFamily: string;\n  fontSize: number;\n  fromTypoMetrics?: boolean;\n}\n\nexport const Baseline: FC<Baseline> = ({\n  fontFamily,\n  fontSize,\n  fromTypoMetrics = false,\n}) => (\n  <div\n    className={className(\n      hPx(useFontBaseline(fontFamily, fontSize, fromTypoMetrics)),\n      borderCss({ ...baselineBorder, borderWidth: fontSize / 16 }),\n    )}\n  />\n);\n","import { FC } from 'react';\nimport { At } from 'src/component/TwoD/At';\nimport { OmitText, splitBorderDef, Style } from 'src/css';\nimport {\n  Measured,\n  mergeDefaultMeasured,\n  splitMeasured,\n  useTextBoxMetrics,\n} from 'src/font';\n\nexport type TextStyle<S extends Style = Style> = OmitText<S>;\n\nexport type PlainText<S extends Style = Style> = Partial<Measured> &\n  At<TextStyle<S>>;\n\n/**\n * A text div with tighter horizontal padding.\n *\n * A text div with zero horizontal padding will still show some distance\n * between the edge of some characters and the element content edge. This\n * breaks requirements such as horizontally aligned text. The space is the\n * `advance` of the head/final glyphs, used to space out glyphs in a word. We\n * _do_ want this between glyphs, but _not_ at the head/final glyph.\n *\n * This code exists until CSS gets the required font metrics. If you set\n * horizontal padding to zero, then that will be precisely the distance between\n * the text and the element edge, regardless of the glyph, font family or font\n * size. Uses the font metrics to compute the `advance` of the head/last glyphs,\n * then clips and shifts the text accordingly.\n *\n * Owns the style keys:\n * 1. `width`\n * 1. `fontFamily`\n * 1. `fontSize`\n * 1. `textIndent`\n * 1. `lineHeight\n * 1. `padding`\n * 1. `paddingLeft`\n * 1. `paddingRight`\n * 1. `transform`\n * 1. `border`\n * 1. `border(top|bottom|left|right)`\n * 1. `border(top|bottom|left|right)(style|width|color)`\n *\n * Text:\n * @param fontFamily must be loaded by the font manager\n * @param fontSize in pixels\n * @param text\n * @param hPad ½ of total horizontal padding in pixels\n *\n * Border props:\n * @param borderWidth\n * @param borderColor\n * @param borderStyle\n * @param borderEdges set to any value other than `none` to show a border on\n * the specified edges. Default is show no border\n *\n * Point translate props:\n * @param x\n * @param y\n * @param z\n */\nexport const PlainText: FC<PlainText> = ({\n  children,\n  styles = [],\n  ...props\n}) => {\n  const [measured, rest] = splitMeasured(props),\n    [borderDef, point] = splitBorderDef(rest),\n    textDef = mergeDefaultMeasured(measured),\n    textStyle = useTextBoxMetrics(textDef);\n\n  return (\n    <At styles={[textStyle, ...styles]} {...borderDef} {...point} {...rest}>\n      {textDef.text}\n      {children}\n    </At>\n  );\n};\n","import { FC } from 'react';\nimport { Baseline } from 'src/component/TwoD/Text/Baseline';\nimport { PlainText } from 'src/component/TwoD/Text/PlainText';\nimport { Style } from 'src/css';\nimport { mergeDefaultMeasured } from 'src/font';\n\nexport interface MetricText<S extends Style = Style> extends PlainText<S> {\n  fromTypoMetrics?: boolean;\n}\n\n/**\n * A `PlainText` component but with an overlay showing some font metrics:\n *\n * * Baseline\n * * Left/right edges of the measured text\n *\n * @param fromTypoMetrics uses `WinMetrics` by default. If this flag is true\n * then font metrics will be read from the font `OS/2` table `TypoMetrics`\n * entries as used on Linux Chrome.\n */\nexport const MetricText: FC<MetricText> = ({\n  fromTypoMetrics,\n  children,\n  ...props\n}) => {\n  const { fontFamily, fontSize } = mergeDefaultMeasured(props);\n  return (\n    <PlainText {...props}>\n      <Baseline {...{ fromTypoMetrics, fontFamily, fontSize }} />\n      {children}\n    </PlainText>\n  );\n};\n","import { FC } from 'react';\nimport { At } from 'src/component/TwoD/At';\nimport { MetricText } from 'src/component/TwoD/Text/MetricText';\nimport { PlainText, TextStyle } from 'src/component/TwoD/Text/PlainText';\nimport { Style } from 'src/css';\nimport { Measured, measuredKeys } from 'src/font';\nimport { split } from 'src/util';\n\nexport * from 'src/component/TwoD/Text/MetricText';\nexport * from 'src/component/TwoD/Text/PlainText';\n\n/**\n * The type of props used by components that show text and possibly font\n * metrics\n **/\nexport interface MetricProps extends Partial<Measured> {\n  showMetrics?: boolean;\n  fromTypoMetrics?: boolean;\n}\n\nexport type Text<S extends Style = Style> = At<TextStyle<S>> & MetricProps;\nexport type TextKey = keyof MetricProps;\n\nexport const textKeys: TextKey[] = [\n    'showMetrics',\n    'fromTypoMetrics',\n    ...measuredKeys,\n  ],\n  splitText = split(textKeys);\n\n/**\n * A `PlainText` component that optionally shows some font metrics\n *\n * Font metrics:\n * @param showMetrics  - set to `true` to overlay the baseline ruler over the\n * component. Default is false\n * @param fromTypoMetrics - uses `WinMetrics` by default. If this flag is true\n * then font metrics will be read from the `OS/2` table `TypoMetrics`\n * entries. Default is false\n *\n * Text props:\n * @param text\n * @param fontFamily\n * @param fontSize\n * @param hPad\n *\n * Border props:\n * @param borderWidth\n * @param borderColor\n * @param borderStyle\n * @param borderEdges\n *\n * Point translate props:\n * @param x\n * @param y\n * @param z\n */\nexport const Text: FC<Text> = ({ showMetrics = false, children, ...props }) => {\n  const TextTag = showMetrics ? MetricText : PlainText;\n\n  return <TextTag {...props}>{children}</TextTag>;\n};\n","import { FC } from 'react';\nimport { BorderedAt } from 'src/component/TwoD/At';\nimport { NoDirFlexStyle, VFlex } from 'src/component/TwoD/Flex';\nimport { MetricProps, Text } from 'src/component/TwoD/Text';\nimport {\n  addBorderEdges,\n  backgroundColor,\n  Color,\n  css,\n  foregroundColor,\n  splitEdgeDef,\n  Style,\n  topRightBorderRadius,\n} from 'src/css';\nimport { fallbackFontSize } from 'src/font';\nimport { splitPoint } from 'src/geometry';\n\nexport interface LabeledProps {\n  labelColor?: Color;\n  labelBgColor?: Color;\n  labelOpacity?: number;\n  isThreeD?: boolean;\n}\n\nexport type LabeledKey = keyof LabeledProps;\n\n/**\n * `Labeled` component is bordered on all edges.\n */\nexport type Labeled<S extends Style = Style> = LabeledProps &\n  MetricProps &\n  BorderedAt<NoDirFlexStyle<S>>;\n\n/**\n * A container that adds a label above its children.\n *\n * Label colors:\n * @param labelColor label text color\n * @param labelBgColor label text background color\n * @param labelOpacity\n * @param isThreeD set to true if children have a Z dimension\n *\n * Label text props:\n * @param text label text\n * @param fontFamily label font family\n * @param fontSize label font size in pixels, default is `12`\n * @param hPad total horizontal label padding in pixels\n * @param showMetrics\n * @param fromTypoMetrics\n *\n * Border edge props. `borderEdges` is fixed at `all`.\n * @param borderWidth\n * @param borderColor\n * @param borderStyle\n *\n * Point translate props:\n * @param x\n * @param y\n * @param z\n */\nexport const Labeled: FC<Labeled> = ({\n  labelColor = 'black',\n  labelBgColor = '#fffff0',\n  labelOpacity: opacity = 1,\n  isThreeD = false,\n  children,\n  styles = [],\n  ...props\n}) => {\n  const [edgeDef, noEdge] = splitEdgeDef(props),\n    [point, userTextProps] = splitPoint(noEdge),\n    textProps = fallbackFontSize(12)(userTextProps);\n\n  const labelStyles = [\n    backgroundColor(labelBgColor),\n    foregroundColor(labelColor),\n    topRightBorderRadius((3 / 4) * textProps.fontSize),\n    { opacity },\n  ];\n\n  const threeDStyle = isThreeD ? css.preserveThreed : {},\n    borderFor = addBorderEdges(edgeDef);\n\n  return (\n    <VFlex {...point} styles={[threeDStyle, ...styles]} gap={0}>\n      <Text {...textProps} {...borderFor('noBottom')} styles={labelStyles} />\n      {children}\n    </VFlex>\n  );\n};\n","import { FC } from 'react';\nimport { BoxDef, BoxFace } from 'src/component/ThreeD/Box/Face';\nimport { ThreeDFaces } from 'src/component/ThreeD/Box/types';\nimport { At, BorderedAt } from 'src/component/TwoD';\nimport { css, OmitPosition, Style } from 'src/css';\nimport { splitPoint } from 'src/geometry';\n\nexport type Box<S extends Style = Style> = BorderedAt<OmitPosition<S>> & BoxDef;\n\nconst defaultCss = { ...css.relative, ...css.preserveThreed };\n\n/** Actually an `Irregular Rectangular Prism`. */\nexport const Box: FC<Box> = ({ children, styles = [], ...props }) => {\n  const [point, commonFaceProps] = splitPoint(props);\n\n  return (\n    <At {...point} styles={[defaultCss, ...styles]}>\n      <BoxFace face=\"front\" {...commonFaceProps}>\n        {children}\n      </BoxFace>\n      {ThreeDFaces.map(face => (\n        <BoxFace {...{ face }} {...commonFaceProps} key={face} />\n      ))}\n    </At>\n  );\n};\n","import { FC } from 'react';\nimport { At } from 'src/component/TwoD/At';\nimport { css, OmitPosition } from 'src/css';\n\nexport type Panel = At<OmitPosition>;\n\nconst defaultStyle = {\n  ...css.relative,\n  ...css.minContentWidth,\n  // must wrap $nest with `['']` for benefit of eslint\n  ['$nest']: { '&>*': css.absolute },\n};\n\n/**\n * A layout component for absolutely positioned children. Set `style.top/left`\n * on children to position them.\n */\nexport const Panel: FC<Panel> = ({ children, styles = [], ...props }) => (\n  <At styles={[defaultStyle, ...styles]} {...props}>\n    {children}\n  </At>\n);\n","import { px } from 'csx';\nimport { FC } from 'react';\nimport { Box } from 'src/component/ThreeD/Box/component';\nimport {\n  BoxDef,\n  mergeDefaultBoxDef,\n  splitBoxDef,\n} from 'src/component/ThreeD/Box/Face';\nimport { Labeled } from 'src/component/TwoD';\nimport { mergeDefaultEdgeDef, splitEdgeDef } from 'src/css';\nimport { splitPoint } from 'src/geometry';\n\nexport interface LabeledBox extends Labeled, BoxDef {\n  zLevel?: number;\n}\n\n/** A container that renders a label above its children and a rectangular prism\n * behind them. */\nexport const LabeledBox: FC<LabeledBox> = ({\n  zLevel = 0,\n  children,\n  styles = [],\n  ...props\n}) => {\n  const [userEdgeDef, noEdgeDef] = splitEdgeDef(props),\n    [{ z = '0px', ...point }, noPoint] = splitPoint(noEdgeDef),\n    [userBoxDef, labeled] = splitBoxDef(noPoint);\n\n  const { borderWidth, ...edgeDef } = mergeDefaultEdgeDef(userEdgeDef),\n    edgeProps = { borderWidth, ...edgeDef };\n\n  const { depth, ...boxDef } = mergeDefaultBoxDef(userBoxDef),\n    boxProps = { depth, ...boxDef, ...edgeProps };\n\n  const labeledProps = {\n    ...edgeProps,\n    ...labeled,\n    ...point,\n    z: `calc(${z} + ${px(zLevel * depth + 2 * borderWidth)})`,\n  };\n\n  return (\n    <Labeled {...labeledProps} {...{ styles }} isThreeD>\n      <Box {...boxProps}>{children}</Box>\n    </Labeled>\n  );\n};\n","import { FC } from 'react';\nimport { LabeledBox } from 'src/component/ThreeD/LabeledBox';\nimport { splitText, Text } from 'src/component/TwoD/Text';\n\nexport type LabeledTextBox = LabeledBox & { labelText?: string };\n\n/** A `LabeledBox` whose child is a `Text` component */\nexport const LabeledTextBox: FC<LabeledTextBox> = ({\n  labelText = 'label',\n  children,\n  styles = [],\n  ...props\n}) => {\n  const [{ text, ...textProps }, noText] = splitText(props);\n\n  return (\n    <LabeledBox text={labelText} {...noText} {...textProps} {...{ styles }}>\n      <Text {...textProps} {...{ text }} />\n      {children}\n    </LabeledBox>\n  );\n};\n","import { FC } from 'react';\nimport { BoxFace } from 'src/component/ThreeD/Box/Face';\nimport { LabeledBox } from 'src/component/ThreeD/LabeledBox';\nimport { LabeledTextBox } from 'src/component/ThreeD/LabeledTextBox';\nimport { Flex } from 'src/component/TwoD';\nimport { FlexDir } from 'src/css';\n\ninterface Leaf {\n  args: LabeledTextBox;\n}\n\nexport interface Branch {\n  args: BoxFace;\n  text: string;\n  dir: FlexDir;\n  nodes: readonly Node[];\n}\n\ninterface TwoDBranch {\n  dir: FlexDir;\n  nodes: readonly Node[];\n}\n\ntype Node = Leaf | Branch | TwoDBranch;\ntype LeafFn = (args: LabeledTextBox) => Leaf;\ntype LeafKey = typeof leafKeys[number];\ntype CurriedLeafFn = (common?: Partial<LabeledBox>) => (text: string) => Leaf;\ntype NewLeaf = Record<LeafKey, CurriedLeafFn> & LeafFn;\n\nconst leafKeys = ['link', 'textField', 'fontPicker'] as const,\n  isLeaf = (x: Node): x is Leaf => !('dir' in x),\n  isBranch = (x: Node): x is Branch => 'dir' in x && 'text' in x,\n  isTwoDBranch = (x: Node): x is TwoDBranch => !('text' in x);\n\nexport const matchNode = (\n  f: FC<Leaf>,\n  g: FC<Branch>,\n  h: FC<TwoDBranch>,\n  empty: JSX.Element,\n) => (node: Node) =>\n  isLeaf(node)\n    ? f(node)\n    : isBranch(node)\n    ? g(node)\n    : isTwoDBranch(node)\n    ? h(node)\n    : () => empty;\n\nconst renderNode = (node: Node, idx: number) =>\n  matchNode(\n    leaf => <Leaf {...leaf} key={idx} />,\n    branch => <Branch {...branch} key={idx} />,\n    twoDBranch => <TwoDBranch {...twoDBranch} key={idx} />,\n    <></>,\n  )(node);\n\nexport const Leaf: FC<Leaf> = ({ args }) => <LabeledTextBox {...args} />,\n  TwoDBranch: FC<TwoDBranch> = ({ nodes, dir }) => (\n    <Flex {...{ dir }} styles={[{ paddingTop: 0 }]}>\n      {nodes.map(renderNode)}\n    </Flex>\n  ),\n  Branch: FC<Branch> = ({ nodes, dir, args, ...props }) => (\n    <LabeledBox {...props} {...args}>\n      <Flex {...{ dir }}>{nodes.map(renderNode)}</Flex>\n    </LabeledBox>\n  );\n\n/** * 3D tree leaf */\nexport const leaf: NewLeaf = (() => {\n    const fn: LeafFn = args => ({ args }),\n      res = fn as NewLeaf,\n      curryFn = (labelText: string) => (common: Partial<LabeledBox> = {}) => (\n        text: string,\n      ) => leaf({ labelText, text, ...common });\n\n    res.link = curryFn('Link');\n    res.textField = curryFn('TextField');\n    res.fontPicker = curryFn('FontPicker');\n\n    return res;\n  })(),\n  curryLeaf = (common: LabeledTextBox) => leafKeys.map(k => leaf[k](common));\n\n/**\n * 1. `rowBranch` - 3D horizontal flex tree branch\n * 1. `columnBranch` - 3D vertical flex tree branch\n * 1. `vertical` - 2D vertical flex tree branch\n */\nexport const rowBranch = (args: Partial<BoxFace>) => (\n    text: string,\n    ...nodes: Node[]\n  ): Branch => ({\n    text,\n    nodes,\n    dir: 'row',\n    args,\n  }),\n  columnBranch = (args: Partial<BoxFace>) => (\n    text: string,\n    ...nodes: Node[]\n  ): Branch => ({\n    text,\n    nodes,\n    dir: 'column',\n    args,\n  }),\n  vertical = (...nodes: Node[]) => ({ nodes, dir: 'column' as FlexDir });\n","export const Demos = () => {};\n\nimport { ReactElement } from 'react';\nimport { Box, LabeledBox, LabeledTextBox } from 'src/component/ThreeD';\nimport { Labeled, Text, VFlex } from 'src/component/TwoD';\nimport { css } from 'src/css';\n\nconst plainText: Text = { showMetrics: true, text: 'HELLO' },\n  labeled = { ...plainText, text: 'Label' },\n  labeledText = { ...plainText, labelText: 'Label' };\n\nconst hello = (props?: Text) => <Text {...plainText} {...props} />;\n\nexport interface Demo {\n  name: string;\n  component: ReactElement;\n}\n\nexport const demos = [\n  { name: 'Text + baseline', component: hello() },\n  { name: 'Text + border', component: hello({ borderEdges: 'all' }) },\n  { name: 'hPad = 0', component: hello({ borderEdges: 'all', hPad: 0 }) },\n  {\n    name: 'Labeled',\n    component: (\n      <Labeled {...labeled}>\n        {hello({ borderEdges: 'all', styles: [css.whiteBg] })}\n      </Labeled>\n    ),\n  },\n  { name: 'Box', component: <Box>HELLO</Box> },\n  {\n    name: 'The “transparent” theme',\n    component: <Box boxThemeKey=\"transparent\">HELLO</Box>,\n  },\n  {\n    name: 'The “yellowOrange” theme',\n    component: <Box boxThemeKey=\"yellowOrange\">HELLO</Box>,\n  },\n  {\n    name: 'LabeledBox',\n    component: <LabeledBox {...labeled}>{hello()}</LabeledBox>,\n  },\n  {\n    name: 'Grayscale LabeledBox',\n    component: (\n      <LabeledBox zLevel={1} boxThemeKey=\"grayscale\" {...labeled}>\n        {hello()}\n      </LabeledBox>\n    ),\n  },\n  {\n    name: 'Stacked LabeledBox',\n    component: (\n      <LabeledBox {...labeled}>\n        <LabeledBox zLevel={1} {...labeled}>\n          {hello()}\n        </LabeledBox>\n      </LabeledBox>\n    ),\n  },\n  { name: 'LabeledTextBox', component: <LabeledTextBox {...labeledText} /> },\n  {\n    name: 'opacity = 0.4',\n    component: <LabeledTextBox {...labeledText} opacity={0.4} zLevel={1} />,\n  },\n  {\n    name: 'Is 6 levels enough?',\n    component: (\n      <LabeledBox text=\"Level 1\" zLevel={1}>\n        <VFlex>\n          <LabeledBox text=\"Level 2\" zLevel={1} opacity={0.7}>\n            <VFlex>\n              <LabeledBox text=\"Level 3\" zLevel={1} opacity={0.6}>\n                <VFlex>\n                  <LabeledBox text=\"Level 4\" zLevel={1} opacity={0.5}>\n                    <VFlex>\n                      <LabeledBox text=\"Level 5\" zLevel={1} opacity={0.4}>\n                        <VFlex>\n                          <LabeledTextBox\n                            zLevel={1}\n                            {...labeledText}\n                            opacity={0.3}\n                          />\n                        </VFlex>\n                      </LabeledBox>\n                    </VFlex>\n                  </LabeledBox>\n                </VFlex>\n              </LabeledBox>\n            </VFlex>\n          </LabeledBox>\n        </VFlex>\n      </LabeledBox>\n    ),\n  },\n];\n","import { FC, ReactElement } from 'react';\nimport reactElementToJSXString from 'react-element-to-jsx-string';\nimport { HFlex, Labeled } from 'src/component/TwoD';\nimport { Styled } from 'src/component/types';\nimport { backgroundColor, css, defaultCss } from 'src/css';\nimport { style } from 'typestyle';\nimport { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';\nimport { ghcolors as colors } from 'react-syntax-highlighter/dist/esm/styles/prism';\nimport { scale } from 'csx';\n\nconst decode = reactElementToJSXString;\n\ninterface Source extends Styled {\n  idx: number;\n  name?: string;\n  component: ReactElement;\n}\n\nconst componentSourceStyles = [\n  css.borderBox,\n  css.h100,\n  css.alignBaseline,\n  backgroundColor('#f0f0f0ac'),\n];\n\nexport const Source: FC<{ component: ReactElement }> = ({ component }) => (\n  <SyntaxHighlighter language=\"tsx\" style={colors}>\n    {decode(component, { filterProps: ['key'] })}\n  </SyntaxHighlighter>\n);\n\nexport const ComponentSource: FC<Source> = ({\n  idx,\n  name = 'Anonymous',\n  component,\n}) => (\n  <Labeled text={`${idx + 1}. ${name}`}>\n    <HFlex styles={componentSourceStyles} borderEdges=\"all\">\n      {component}\n      <div style={{ fontSize: '9px' }}>\n        <Source {...{ component }} />\n      </div>\n    </HFlex>\n  </Labeled>\n);\n","import { FC } from 'react';\nimport { Styled } from 'src/component/types';\nimport { css, defaultCss } from 'src/css';\n\nconst className = defaultCss(css.wh100);\n\nexport const Stage: FC<Styled> = ({ children, styles = [] }) => {\n  return <div className={className(...styles)}>{children}</div>;\n};\n","import { FC } from 'react';\nimport { Styled } from 'src/component/types';\nimport { css, gridBackground, GridConfig, OmitBackground } from 'src/css';\nimport { style } from 'typestyle';\n\nexport type Scene = Styled<OmitBackground> & Partial<GridConfig>;\n\nexport const Scene: FC<Scene> = ({ children, styles = [], ...grid }) => (\n  <div className={style(gridBackground(grid), ...styles)}>{children}</div>\n);\n\nexport const IsoScene: FC<Scene> = ({ styles = [], children, ...props }) => (\n  <Scene {...props} styles={[css.isometric, ...styles]}>\n    {children}\n  </Scene>\n);\n","import { flow, pipe } from 'fp-ts/lib/function';\nimport { css, rotate, Style } from 'src/css';\nimport { Angle3 } from 'src/geometry';\nimport { mergeDefined } from 'src/util';\n\ninterface Camera {\n  angle?: Angle3;\n}\n\nexport type Cameras = typeof cameras;\nexport type CameraKey = keyof Cameras;\n\nconst cameras = {\n  front: {},\n  back: { angle: { y: -180 } },\n  top: { angle: { x: -90 } },\n  bottom: { angle: { x: 90 } },\n  left: { angle: { y: 90 } },\n  right: { angle: { y: -90 } },\n\n  iso: { angle: { x: -30, y: 30 } },\n  invIso: { angle: { x: 30, y: -30 } },\n  iso45: { angle: { x: -15, y: 45 } },\n  invIso45: { angle: { x: 15, y: -45 } },\n\n  frontTopLeft: { angle: { x: -45, y: 45 } },\n  frontTopRight: { angle: { x: -45, y: -45 } },\n  frontBottomLeft: { angle: { x: 45, y: 45 } },\n  frontBottomRight: { angle: { x: 45, y: -45 } },\n} as const;\n\nexport const cameraKeys = Object.keys(cameras) as CameraKey[];\n\nconst camera = (key: CameraKey): Camera => cameras[key],\n  cameraAngle = (camera?: Camera): Angle3 =>\n    mergeDefined({ x: 0, y: 0, z: 0 })(camera?.angle ?? {});\n\nexport const cameraKeyAngle = flow(camera, cameraAngle),\n  cameraStyle = (key: CameraKey): Style => ({\n    ...css.centerOrigin,\n    transform: pipe(key, cameraKeyAngle, rotate),\n  });\n","import { flow, pipe } from 'fp-ts/lib/function';\nimport { CameraKey, cameraKeyAngle } from 'src/component/Viewport/camera';\nimport { invAngle, rotate } from 'src/css';\nimport { Angle3 } from 'src/geometry';\nimport { defined } from 'src/util';\nimport { keyframes } from 'typestyle';\n\nexport type Orbit = typeof Orbits[number];\nexport type OrbitAnimation = (cameraKey: CameraKey) => (orbit: Orbit) => string;\n\ntype OrthoOrbit = keyof Angle3;\n\nexport const OrthoOrbits: OrthoOrbit[] = ['x', 'y', 'z'],\n  Orbits = [...OrthoOrbits, 'xy', 'xz', 'yz', 'xyz'] as const;\n\nconst invAngle3 = ({ x, y, z }: Angle3) => (orbit: Orbit): Angle3 => {\n  const inverseOrbitKey = (\n    key: 'x' | 'y' | 'z',\n    value: number | undefined,\n  ) => ({\n    [key]: !defined(value) ? 0 : orbit.includes(key) ? invAngle(value) : value,\n  });\n\n  return {\n    ...inverseOrbitKey('x', x),\n    ...inverseOrbitKey('y', y),\n    ...inverseOrbitKey('z', z),\n  };\n};\n\nconst orbitFrames = (from: Angle3) => (orbit: Orbit): string =>\n  keyframes({\n    from: { transform: rotate(from) },\n    to: { transform: pipe(orbit, invAngle3(from), rotate) },\n  });\n\n/** Generate an animation name from an orbit and a camera angle. */\nexport const orbitAnimation: OrbitAnimation = flow(cameraKeyAngle, orbitFrames);\n","import { pipe } from 'fp-ts/lib/function';\nimport { FC } from 'react';\nimport { IsoScene } from 'src/component/Scene';\nimport { Styled } from 'src/component/types';\nimport { CameraKey, cameraStyle } from 'src/component/Viewport/camera';\nimport { Orbit, orbitAnimation } from 'src/component/Viewport/orbit';\nimport { animation, css, defaultCss, GridConfig } from 'src/css';\nimport { style } from 'typestyle';\n\nexport * from 'src/component/Viewport/camera';\nexport * from 'src/component/Viewport/orbit';\n\nexport interface Viewport extends Partial<GridConfig>, Styled {\n  camera?: CameraKey;\n  orbit?: Orbit;\n  scale?: number;\n  isOrbiting?: boolean;\n  periodSec?: number;\n  perspective?: string;\n}\n\nconst className = defaultCss(css.topLeftOrigin);\n\nexport const Viewport: FC<Viewport> = ({\n  camera = 'iso' as CameraKey,\n  orbit = 'y',\n  scale = 1,\n  isOrbiting = false,\n  periodSec = 10,\n  perspective = '90em',\n  styles = [],\n  children,\n  ...props\n}) => {\n  const animationName = orbitAnimation(camera)(orbit),\n    keyframeStyle = pipe(periodSec, animation(animationName)),\n    playStyle = isOrbiting ? css.play : css.pause,\n    animationStyles = [\n      cameraStyle(camera),\n      keyframeStyle,\n      playStyle,\n      css.centerOrigin,\n    ];\n\n  return (\n    <div className={className(...styles)}>\n      <div className={style({ transform: `scale(${scale})`, perspective })}>\n        <IsoScene {...props} styles={animationStyles}>\n          {children}\n        </IsoScene>\n      </div>\n    </div>\n  );\n};\n","import { viewHeight, viewWidth } from 'csx';\nimport { pipe } from 'fp-ts/lib/function';\nimport * as RA from 'fp-ts/ReadonlyArray';\nimport { demos } from 'src/component/Demos';\nimport { ComponentSource } from 'src/component/Source';\nimport { Stage } from 'src/component/Stage';\nimport { HFlex } from 'src/component/TwoD';\nimport { Viewport } from 'src/component/Viewport';\nimport { css, translate } from 'src/css';\nimport { style } from 'typestyle';\n\nconst scale = 1,\n  [x, y] = pipe([viewWidth, viewHeight], RA.ap([100 * ((scale - 1) / 2)])),\n  styles = [{ transform: translate({ x, y }), padding: viewWidth(10) }],\n  rootClassName = style(css.wh100, css.autoOverflow);\n\nexport const App = () => (\n  <Stage>\n    <div className={rootClassName}>\n      <Viewport\n        orbit=\"y\"\n        strokeWidth={1}\n        periodSec={60}\n        isOrbiting\n        {...{ scale }}\n        {...{ styles }}\n      >\n        <HFlex wrap styles={[css.stretch]}>\n          {demos.map(({ name, component }, idx) => (\n            <ComponentSource key={idx} {...{ idx, name, component }} />\n          ))}\n        </HFlex>\n      </Viewport>\n    </div>\n  </Stage>\n);\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { App } from 'src/component';\nimport { FontContext, withFontManager } from 'src/font';\nimport 'src/style/fonts.css';\nimport 'src/style/reset.css';\n\nwithFontManager(\n  fontManager =>\n    void ReactDOM.render(\n      <FontContext.Provider value={fontManager}>\n        <App />\n      </FontContext.Provider>,\n      document.getElementById('root'),\n    ),\n);\n","export * from 'src/css/border';\nexport * from 'src/css/builders';\nexport * from 'src/css/grid';\nexport * from 'src/css/lib';\nexport * from 'src/css/safeStyles';\nexport * from 'src/css/types';\nexport * from 'src/css/util';\nexport * from 'src/css/valueTypes';\n","import * as RE from 'fp-ts/ReadonlyRecord';\nimport {\n  BorderEdges,\n  HorizontalPadEdges,\n  PadDirMultiplier,\n  VerticalPadEdges,\n} from 'src/css/border/constants';\nimport {\n  BorderDef,\n  BorderDefKey,\n  BorderEdge,\n  EdgeDef,\n  EdgeDefKey,\n} from 'src/css/border/types';\nimport { Style } from 'src/css/types';\nimport { pxValue, ucFirst } from 'src/css/util';\nimport { mergeDefined, split, ToRequired } from 'src/util';\n\nexport * from 'src/css/border/constants';\nexport * from 'src/css/border/types';\n\nexport const defaultEdgeDef: Required<EdgeDef> = {\n    borderWidth: 1,\n    borderStyle: 'solid',\n    borderColor: 'black',\n  },\n  defaultBorderDef: Required<BorderDef> = {\n    ...defaultEdgeDef,\n    borderEdges: 'none',\n  };\n\nexport const edgeDefKeys = Object.keys(defaultEdgeDef) as EdgeDefKey[],\n  borderDefKeys = Object.keys(defaultBorderDef) as BorderDefKey[];\n\nexport const mergeDefaultEdgeDef: ToRequired<EdgeDef> = mergeDefined(\n    defaultEdgeDef,\n  ),\n  mergeDefaultBorderDef: ToRequired<BorderDef> = mergeDefined(defaultBorderDef);\n\nexport const splitEdgeDef = split(edgeDefKeys),\n  splitBorderDef = split(borderDefKeys);\n\n/**\n * True if border definition defines a border to be drawn. A `transparent`\n * border with `borderEdges > 0` and `borderWidth > 0` will return true because\n * this border still takes up layout space.\n **/\nexport const hasBorder = (borderDef: BorderDef = {}): boolean =>\n  !RE.isEmpty(borderDef) &&\n  borderDef.borderEdges !== 'none' &&\n  borderDef.borderWidth !== 0;\n\n/**\n * Measure pixels taken up by the horizontal borders. Sum of `left` and `right`\n * border width.\n **/\nexport const measureBorderHPad = (borderDef: BorderDef = {}): number => {\n  if (!hasBorder(borderDef)) return 0;\n  const { borderEdges, borderWidth } = mergeDefaultBorderDef(borderDef);\n\n  return borderWidth * PadDirMultiplier[HorizontalPadEdges[borderEdges]];\n};\n\n/**\n * Measure pixels taken up by the vertical borders. Sum of `top` and `bottom`\n * border width.\n **/\nexport const measureBorderVPad = (borderDef: BorderDef = {}): number => {\n  if (!hasBorder(borderDef)) return 0;\n  const { borderEdges, borderWidth } = mergeDefaultBorderDef(borderDef);\n\n  return borderWidth * PadDirMultiplier[VerticalPadEdges[borderEdges]];\n};\n\nexport const measureBorderPad = (\n  borderDef: BorderDef = {},\n): [number, number] => [\n  measureBorderHPad(borderDef),\n  measureBorderVPad(borderDef),\n];\n\n/** Add border edges to an `EdgeDef` making a `BorderDef` */\nexport const addBorderEdges = (edgeDef: EdgeDef) => (\n  borderEdges: BorderEdge = 'all',\n): BorderDef & { borderEdges: BorderEdge } => ({\n  ...edgeDef,\n  borderEdges,\n});\n\n/**\n * Convert a border definition into a style object.\n *\n * @param borderDef The border definition: `borderWidth`, `borderStyle`,\n * `borderColor`, and `borderEdges`.\n * @returns Style object\n */\nexport const borderCss = (borderDef: BorderDef = {}): Style => {\n  if (!hasBorder(borderDef)) return {};\n\n  const {\n    borderWidth,\n    borderStyle,\n    borderColor,\n    borderEdges,\n  } = mergeDefaultBorderDef(borderDef);\n\n  const edgeList: readonly BorderEdge[] = BorderEdges[borderEdges];\n\n  return Object.fromEntries(\n    edgeList.map(edge => [\n      `border${ucFirst(edge)}`,\n      [pxValue(borderWidth), borderStyle, borderColor].join(' '),\n    ]),\n  );\n};\n\n/**\n * @param edgeDef `borderWidth`, `borderStyle` and\n * `borderColor`\n * @returns Style object\n */\nexport const allBordersCss = (edgeDef: EdgeDef = {}): Style =>\n  borderCss({ ...edgeDef, borderEdges: 'all' });\n","import { css } from 'src/css/lib';\nimport { Style } from 'src/css/types';\nimport { emValue, maybePxValue, pxRecord, pxValue } from 'src/css/util';\nimport { Color } from 'src/css/valueTypes';\nimport { Angle3, Point, ThreeDAxis } from 'src/geometry';\nimport { defined, EmptyRecord } from 'src/util';\n\nexport const add100px = (d: number) => `calc(100% + ${pxValue(d)})`;\n\nexport const translate = ({ x, y, z }: Point): string =>\n    [\n      ['X', x],\n      ['Y', y],\n      ['Z', z],\n    ]\n      .map(([k, v]) => (defined(v) ? `translate${k}(${maybePxValue(v)})` : ''))\n      .join(' '),\n  rotate = ({ x, y, z }: Angle3): string =>\n    [\n      ['X', x],\n      ['Y', y],\n      ['Z', z],\n    ]\n      .map(([k, v]) => (defined(v) ? `rotate${k}(${v ?? 0}deg)` : ''))\n      .join(' '),\n  rotateX = (angle: number) => rotate({ x: angle }),\n  rotateY = (angle: number) => rotate({ y: angle }),\n  rotateZ = (angle: number) => rotate({ z: angle }),\n  rotateBy = (axis: ThreeDAxis) => (angle: number) => rotate({ [axis]: angle }),\n  invAngle = (deg: number): number =>\n    deg % 360 === 0 ? Math.abs(360 - deg) : (deg - Math.sign(deg) * 360) % 360,\n  translateLeft = (shift: number) => ({ x: pxValue(-1 * shift) } as const),\n  translateRight = (shift: number) => ({ x: pxValue(shift) } as const);\n\nexport const flexGap = (\n    gap: number | string | undefined,\n  ): EmptyRecord | { gap: string & {} } =>\n    defined(gap)\n      ? {\n          gap: `${maybePxValue(gap)}`,\n        }\n      : {},\n  hFlexGapPx = (gap: number | string | undefined): Style => ({\n    ...flexGap(gap),\n    ...css.hFlex,\n  }),\n  vFlexGapPx = (gap: number | string | undefined): Style => ({\n    ...flexGap(gap),\n    ...css.vFlex,\n  }),\n  hPadding = (pad: number | string) =>\n    ({\n      paddingLeft: maybePxValue(pad),\n      paddingRight: maybePxValue(pad),\n    } as const),\n  marginPx = (margin: number): Style => ({ margin: pxValue(margin) }),\n  paddingPx = (pad: number): Style => ({ padding: pxValue(pad) });\n\nexport const wPx = (width: number): Style => pxRecord({ width }),\n  hPx = (height: number): Style => pxRecord({ height }),\n  whPx = (width: number, height: number): Style =>\n    pxRecord({\n      width,\n      height,\n    });\n\nexport const backgroundColor = (color: Color): Style => ({ background: color }),\n  foregroundColor = (color: Color): Style => ({ color: color }),\n  emLineHeight = (h: number) =>\n    ({\n      lineHeight: emValue(h),\n      height: emValue(h),\n    } as const),\n  topLeftBorderRadius = (width: number): Style => ({\n    borderTopLeftRadius: pxValue(width),\n  }),\n  topRightBorderRadius = (width: number): Style => ({\n    borderTopRightRadius: pxValue(width),\n  }),\n  animation = (animationName: string) => (periodSec: number): Style => ({\n    animationName,\n    animationDuration: `${periodSec}s`,\n    animationIterationCount: 'infinite',\n    animationTimingFunction: 'linear',\n  });\n","import { deg, px, repeatingLinearGradient } from 'csx';\nimport { CsxColorStop } from 'csx/lib/types';\nimport { pipe } from 'fp-ts/lib/function';\nimport { Style } from 'src/css/types';\nimport { Color } from 'src/css/valueTypes';\nimport { defined, mergeDefined, square } from 'src/util';\n\nexport interface GridConfig {\n  majorStep: number;\n  color: Color;\n  backgroundColor: Color;\n  strokeWidth: number;\n}\n\nconst defaultConfig: GridConfig = {\n  majorStep: 24,\n  color: '#ff000026',\n  backgroundColor: 'transparent',\n  strokeWidth: 0,\n};\n\nconst colorStop = (color: Color, strokeWidth: number): CsxColorStop => [\n    color,\n    px(strokeWidth),\n  ],\n  parallelLines = (majorStep: number, color: Color, strokeWidth: number) => (\n    angle: number,\n    backgroundColor: Color,\n  ): string => {\n    const halfStroke = strokeWidth / 2,\n      bottom = majorStep - halfStroke;\n\n    return repeatingLinearGradient(\n      deg(angle),\n      colorStop(color, 0),\n      colorStop(color, halfStroke),\n      colorStop(backgroundColor, halfStroke),\n      colorStop(backgroundColor, bottom),\n      colorStop(color, bottom),\n      colorStop(color, majorStep),\n    );\n  };\n\n/**\n * A background grid for debugging layout\n *\n * Return values depend on the structure of the given `GridConfig`:\n *\n * ```\n * ┌──────────────────┬───────────┬─────┬─────────────┬──────────┐\n * │     Outcome      │ majorStep │     │ strokeWidth │ bgColor  │\n * ├──────────────────┼───────────┼─────┼─────────────┼──────────┤\n * │Empty style       │       = 0 │ OR  │         = 0 │ !defined │\n * ├──────────────────┼───────────┼─────┼─────────────┼──────────┤\n * │Flat bg color     │       = 0 │ OR  │         = 0 │  defined │\n * ├──────────────────┼───────────┼─────┼─────────────┼──────────┤\n * │Grid pattern      │       ≠ 0 │ AND │         ≠ 0 │ !defined │\n * ├──────────────────┼───────────┼─────┼─────────────┼──────────┤\n * │Grid pattern + bg │       ≠ 0 │ AND │         ≠ 0 │  defined │\n * └──────────────────┴─────────────────┴─────────────┴──────────┘\n * ```\n *\n * Undefined grid config values are replaced with defaults:\n * ```\n * {\n *   majorStep: 12,\n *   color: 'lightgray',\n *   bgColor: 'transparent',\n *   strokeWidth: 0,\n * }\n * ```\n * Examples:\n * ```\n * const noGridOrBg  = gridBackground({strokeWidth: 0});\n * const flatBg      = gridBackground({strokeWidth: 0, bgColor: 'red'});\n * const defaultGrid = gridBackground({});\n * const gridAndBg   = gridBackground({bgColor: 'red'});\n * ```\n **/\nexport const gridBackground = (config: Partial<GridConfig>): Style => {\n  const { majorStep, color, backgroundColor, strokeWidth } = mergeDefined(\n    defaultConfig,\n  )(config);\n\n  if (majorStep === 0 || strokeWidth === 0)\n    return defined(config.backgroundColor) ? { backgroundColor } : {};\n\n  const orthoLines = parallelLines(majorStep, color, strokeWidth),\n    background = [\n      orthoLines(0, 'transparent'),\n      orthoLines(90, backgroundColor),\n    ].join(','),\n    backgroundSize = pipe(pipe(majorStep, px, square).join(' '), square).join(\n      ',',\n    );\n\n  return {\n    background,\n    backgroundAttachment: 'local',\n    backgroundSize,\n  };\n};\n","export const defined = (x: any): x is {} => x !== undefined && x !== null;\n","import { without } from 'fp-ts-std/Array';\nimport { reject } from 'fp-ts-std/Record';\nimport { eqString } from 'fp-ts/lib/Eq';\nimport { not, pipe } from 'fp-ts/lib/function';\nimport { defined } from 'src/util/Any';\nimport { EmptyRecord } from 'src/util/types';\n\n/** Pick a subset of an object by keys.\n```\nconst picked: { a: number; b: string } = picks(\n  'a',\n  'b',\n)({ a: 1, b: 'foo', c: /re/ });\n```\n*/\n\nexport const picks = <KS extends readonly PropertyKey[]>(...keys: KS) => <\n  T extends { [K in KS[number]]: T[K] }\n>(\n  o: T,\n): Pick<T, KS[number]> => {\n  const res = {} as Pick<T, KS[number]>;\n  keys.forEach((key: KS[number]) => {\n    res[key] = o[key];\n  });\n  return res;\n};\n\nexport const mergeN = <T>(...objects: T[]): T => Object.assign({}, ...objects);\n\nexport const filterUndefValues = <T>(\n  unfiltered: Record<string, T>,\n): Record<string, T> => pipe(defined, not, reject)(unfiltered);\n\nexport const mergeDefined = <T extends Record<string, any>>(first: T) => (\n  ...rest: Partial<T>[]\n) => mergeN(...[first, ...rest].map(filterUndefValues)) as T;\n\nexport const isEmptyRecord = (x: Record<PropertyKey, any>): x is EmptyRecord =>\n  !Object.keys(x).length;\n\nexport const split = <K extends string>(keys: K[]) => <\n  T extends Partial<{ [P in K]: T[P] }>\n>(\n  o: T,\n): [Partial<Pick<T, K>>, Omit<T, K>] => {\n  const withKeys: Pick<T, K> = pipe(o, picks(...keys.filter(key => key in o))),\n    restKeys = without(eqString)(keys as string[])(\n      Object.keys(o),\n    ) as (keyof Omit<T, K>)[],\n    withRestKeys = pipe(o, picks(...restKeys));\n  return [withKeys, withRestKeys];\n};\n","export const square = <T>(x: T): readonly [T, T] => [x, x] as const;\n","import { flow, pipe } from 'fp-ts/lib/function';\nimport { Lens } from 'monocle-ts';\nimport { Context, createContext, useContext } from 'react';\nimport { css, emLineHeight, hPadding, pxRecord, Style } from 'src/css';\nimport { FontManager } from 'src/font/manager';\nimport {\n  DefaultLineHeightEm,\n  HMetrics,\n  Measured,\n  mergeDefaultMeasured,\n} from 'src/font/metrics';\nimport { FontMeasure } from 'src/font/types';\n\nexport const FontContext: Context<FontManager> = createContext(\n  new FontManager(),\n);\n\nexport const useFontContext = () => useContext(FontContext);\n\nexport const useFontBaseline = (\n  fontFamily: string,\n  fontSize: number,\n  fromTypoMetrics?: boolean,\n): number =>\n  useFontContext().computeBaseLine(fontFamily, fontSize, fromTypoMetrics);\n\nconst metricsToMeasure: Lens<\n  HMetrics,\n  FontMeasure\n> = Lens.fromProps<HMetrics>()([\n  'text',\n  'fontFamily',\n  'fontSize',\n  'textWidth',\n  'textIndent',\n]);\n\nexport const useFontMetrics = (measured: Partial<Measured>): FontMeasure =>\n  flow(\n    mergeDefaultMeasured,\n    useFontContext().measure,\n    metricsToMeasure.get,\n  )(measured);\n\nexport const useTextBoxMetrics = (measured: Partial<Measured>): Style => {\n  const { fontSize, fontFamily, textWidth: width, textIndent, hPad } = pipe(\n    measured,\n    mergeDefaultMeasured,\n    useFontContext().measure,\n  );\n\n  return {\n    fontFamily,\n    ...css.relative,\n    ...css.noWrap,\n    ...emLineHeight(DefaultLineHeightEm),\n    ...(hPad ? hPadding(hPad) : {}),\n    ...pxRecord({ width, fontSize, textIndent }),\n  };\n};\n","import * as AR from 'fp-ts/lib/Array';\nimport { pipe } from 'fp-ts/lib/function';\nimport { AtRule, Declaration, Expression, Parser } from 'shady-css-parser';\nimport { FetchFont } from 'src/font/types';\nimport { defined } from 'src/util';\n\nconst parser = new Parser();\n\nexport interface CssRule {\n  cssText: string;\n}\n\nexport interface CssFontFaceRule extends CssRule {\n  type: number;\n}\n\nexport interface CssRuleList {\n  [Symbol.iterator](): IterableIterator<CssRule>;\n}\n\nexport interface CssStyleSheet {\n  rules: CssRuleList;\n}\n\nconst parseExpressions = (cssText: string) =>\n  (parser.parse(cssText).rules[0] as AtRule).rulelist?.rules as\n    | Declaration[]\n    | undefined;\n\nconst cleanUrl = (url: string) =>\n    url.replace(/^url\\(\"?/, '').replace(/\"?\\)$/, ''),\n  cleanFamily = (url: string) => url.replace(/\"/g, '');\n\nconst declarationToEntry = (d: Declaration): ['src' | 'fontFamily', string] => [\n  d.name === 'src' ? 'src' : 'fontFamily',\n  pipe((d.value as Expression).text, d.name === 'src' ? cleanUrl : cleanFamily),\n];\n\nconst ruleToFetchFont = ({ cssText }: CssFontFaceRule): FetchFont[] => {\n  const declarations = parseExpressions(cssText);\n  return defined(declarations)\n    ? [pipe(declarations, AR.map(declarationToEntry), Object.fromEntries)]\n    : [];\n};\n\nconst isFontFaceRule = (rule: CssRule): rule is CssFontFaceRule =>\n  (rule as CssFontFaceRule).type === 5;\n\n/** Parse all fonts to be fetched from a stylesheet. */\nexport const sheetToFonts = (styleSheet: CssStyleSheet): FetchFont[] =>\n  pipe(\n    styleSheet.rules,\n    Array.from,\n    AR.filter(isFontFaceRule),\n    AR.chain(ruleToFetchFont),\n  );\n","import fontkit from '@pdf-lib/fontkit';\nimport fs from 'fs';\nimport path from 'path';\nimport { FontManager } from 'src/font/manager';\nimport { FetchedFont, FetchFont } from 'src/font/types';\n\nconst BASE_FONT_PATH = 'src';\n\nconst loadFont = (fetchFont: FetchFont): FetchedFont => {\n  const fontData = fs.readFileSync(path.join(BASE_FONT_PATH, fetchFont.src)),\n    font = fontkit.create(fontData);\n  return { ...fetchFont, font };\n};\n\n/** Sync read filesystem fonts in Node.js. */\nexport const loadLocalFonts = (families: FetchFont[]): FontManager =>\n  new FontManager(...families.map(loadFont));\n","import * as AR from 'fp-ts/lib/Array';\nimport { pipe } from 'fp-ts/lib/function';\nimport { loadFont } from 'src/font/loader/loadRemote';\nimport { sheetToFonts } from 'src/font/loader/styleSheet';\nimport { FontManager } from 'src/font/manager';\n\nexport * from 'src/font/loader/loadLocal';\n\n/** Loads all fonts that appear in stylesheets. */\nexport const loadStyleSheetFonts = (): Promise<FontManager> => {\n  const res = pipe(\n    window.document.styleSheets,\n    Array.from,\n    AR.chain(sheetToFonts),\n    AR.map(loadFont),\n    Promise.all.bind(Promise),\n    FontManager.from,\n  );\n  return res;\n};\n\n/** Runs `f` async with a loaded font manager. */\nexport const withFontManager = <T>(\n  f: (fontManager: FontManager) => T,\n): Promise<T> => loadStyleSheetFonts().then(f);\n","import { Optional } from 'src/util/types';\nimport { Style } from 'src/css/types';\nimport { style } from 'typestyle';\n\nexport const ucFirst = (s: string) => s.charAt(0).toUpperCase() + s.slice(1);\n\nexport const pxValue = (v: number | undefined): string => (v ?? 0) + 'px',\n  maybePxValue = (v: number | string | undefined): string =>\n    v === undefined ? '0px' : isNaN(v as any) ? (v as string) : v + 'px',\n  pxRecord = <K extends string>(v: Record<K, number>) =>\n    Object.fromEntries(\n      Object.entries(v).map(([k, v]) => [k, v + 'px']),\n    ) as Record<K, string>;\n\nexport const emValue = (v: number | undefined): string => (v ?? 0) + 'em';\n\n/** Curried version of `typestyle/style`. */\nexport const defaultCss = (...head: Optional<Style>[]) => (\n  ...tail: Optional<Style>[]\n): string => style(...head, ...tail);\n","import fontkit, { Font } from '@pdf-lib/fontkit';\nimport { FetchedFont, FetchFont } from 'src/font/types';\n\nconst readArrayBuffer = async (blob: Blob): Promise<Buffer> =>\n  new Promise(function (resolve, reject) {\n    const reader = new FileReader();\n    reader.onload = (): void =>\n      resolve(Buffer.from(reader.result as ArrayBuffer));\n    reader.onerror = reject;\n    reader.readAsArrayBuffer(blob);\n  });\n\nexport const loadFont = async (request: FetchFont): Promise<FetchedFont> => {\n  let font: Font;\n  try {\n    const raw = await fetch(request.src),\n      blob = await raw.blob(),\n      buffer = await readArrayBuffer(blob);\n\n    font = fontkit.create(buffer);\n  } catch (e) {\n    e.message = `Failed loading font from \"${request.src}\": ${e.message}`;\n    throw e;\n  }\n  return { ...request, font };\n};\n"],"sourceRoot":""}