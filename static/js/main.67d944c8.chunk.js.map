{"version":3,"sources":["font/useFontMetrics.ts","util/Tuple.ts","font/loader/styleSheet.ts","font/loader/loadLocal.ts","font/loader/index.ts","component/index.ts","font/loader/loadRemote.ts","index.tsx","component/TwoD/At.tsx","component/TwoD/Flex.tsx","component/TwoD/Labeled.tsx","component/TwoD/Panel.tsx","component/ThreeD/Box/HasDepth.ts","component/ThreeD/Box/BorderBox.ts","component/ThreeD/Box/types.ts","component/ThreeD/Box/colors.ts","component/ThreeD/Box/Face.tsx","component/ThreeD/Box/component.tsx","component/ThreeD/LabeledBox.tsx","component/ThreeD/LabeledTextBox.tsx","component/ThreeD/Tower.tsx","geometry/Axis.ts","geometry/Point.ts","css/util.ts","font/index.ts","font/metrics/measured.ts","css/index.ts","font/manager.ts","css/lib.ts","css/merge.ts","font/metrics/horizontal.ts","font/metrics/vertical.ts","component/TwoD/Text/MetricGuides.tsx","component/TwoD/Text/PlainText.tsx","component/TwoD/Text/MetricText.tsx","component/TwoD/Text/index.tsx","component/Base.ts","component/Demos.tsx","css/border/constants.ts","util/Object.ts","css/builders.ts","component/Source.tsx","component/Scene.tsx","component/Viewport/camera.ts","component/Viewport/orbit.ts","component/Viewport/index.tsx","component/App.tsx","css/border/index.ts","css/grid.ts"],"names":["FontContext","createContext","FontManager","useFontContext","useContext","useFontBaseline","fontFamily","fontSize","fromTypoMetrics","computeBaseLine","metricsToMeasure","Lens","fromProps","defaultTextStyle","cssOf","useTextBoxMetrics","measured","textWidth","width","textIndent","flow","mergeDefaultMeasured","measure","get","useFontMetrics","emLineHeight","DefaultLineHeightEm","pxRecord","square","x","parser","Parser","cleanUrl","url","replace","cleanFamily","replaceAll","declarationToEntry","d","name","pipe","value","text","ruleToFetchFont","cssText","declarations","parse","rules","rulelist","parseExpressions","undefined","AR","Object","fromEntries","isFontFaceRule","rule","type","sheetToFonts","styleSheet","Array","from","withFontManager","f","window","document","styleSheets","loadFont","Promise","all","bind","then","async","font","raw","fetch","request","src","blob","buffer","resolve","reject","reader","FileReader","onload","Buffer","result","onerror","readAsArrayBuffer","readArrayBuffer","fontkit","create","e","message","fontManager","ReactDOM","render","Provider","getElementById","At","styles","children","props","className","mergeStyles","baseStyles","Flex","noGap","gap","wrap","dir","padding","css","flexWrap","HFlex","VFlex","Labeled","labelColor","labelBgColor","labelOpacity","opacity","labelHPad","innerBorder","edgeDef","noEdge","splitEdgeDef","point","userTextProps","splitPoint","textProps","fallbackFontSize","labelStyles","top","withDefaultEdgeDef","pluck","px","zIndex","relative","bgColor","fgColor","topRightBorderRadius","hPadding","textBorder","addBorderEdges","is3D","Text","absolute","splitHasDepth","withDefaultHasDepth","defaultHasDepth","defaultHelpers","depth","boxThemeKey","splitBorderedBox","mergeDefaultBorderBox","defaultEdgeDef","FaceKeys3D","FaceKeys","fromTuple","colors","RE","mapColors","idx","BoxThemes","primary","grayscale","i","Math","round","transparent","white","yellowOrange","boxThemeStyle","keys","key","face","boxThemeColor","Transforms","back","bottom","left","right","defaultFaceStyle","layout","borderWidth","axis","shift","pad","byAxis","flag","transform","translate","z","rotateBy","Axis","match","join","isY","height","isX","faceStyle","addBg","borderBox","borderDef","style","allBordersCss","Face","defaultCss","Box","addFrontBg","faceProps","map","LabeledBox","zLevel","userEdgeDef","noEdgeDef","noPoint","userBoxDef","labeled","edgeProps","boxDef","boxProps","labeledProps","LabeledTextBox","labelText","noText","splitText","leaf","res","args","curryFn","common","link","textField","fontPicker","ZeroAngle3","y","axisEq","curry2","eqString","equals","isZ","invDeg","deg","abs","sign","hasDefined","split","ucFirst","s","charAt","toUpperCase","slice","v","toFixed","emRecord","cleanStyles","filter","picks","values","tupled","mergeObjects","defaultClass","head","tail","splitMeasured","defaultMeasured","measuredKeys","constructor","loadedFonts","cache","Map","family","Error","this","size","families","measureText","baseline","computeTypoBaseLine","computeWinBaseLine","unitsPerEm","forEach","loadedFont","set","RA","fonts","atomic","position","boxSizing","contentBox","w100","h100","minContentWidth","centerText","textAlign","hFlex","display","flexDirection","vFlex","flex1","flex","alignBaseline","alignItems","alignTop","alignBottom","stretch","noOverflow","overflow","autoOverflow","noWrap","whiteSpace","whiteBg","background","blackBorder","border","centerOrigin","transformOrigin","leftTopOrigin","threeD","transformStyle","twoD","play","animationPlayState","pause","wh100","composed","absWh100","relWh100","bwBorder","cssClasses","REC","mergeEntry","o1","o2","k","v1","v2","obj","flip","unaryObject","mergeKeys","mergeCssPair","s1","s2","toMerge1","noMerge1","toMerge2","noMerge2","mergeObjectsT","mergeCss","totalMeasured","advanceWidth","bbox","minX","maxX","uemToPx","multiply","divide","bearingRight","readOs2","lineHeight","lineGap","uem","winDescent","winAscent","typoAscender","typoLineGap","typoDescender","baselineBorder","borderColor","borderStyle","borderEdges","MetricGuides","heightPx","borderCss","defaultStyle","PlainText","base","textDef","MetricText","textKeys","showMetrics","TextTag","plainText","labeledText","hello","demos","component","showSource","Layer","levels","blockStyles","fontSizePx","frontClassName","Block","widthPx","Space","Branch","totalWidth","BorderEdges","none","leftRight","noBottom","noTop","topBottom","o","objects","assign","filterNonValues","unfiltered","mergeDefined","first","rest","withKeys","restKeys","without","StringEq","typedKeys","defaultDef","unaryStyle","singleton","pxStyle","entries","rotate","angle","scaleBy","parts","paddingLeft","paddingRight","topLeftBorderRadius","h","animation","animationName","periodSec","animationDuration","animationIterationCount","animationTimingFunction","decode","reactElementToJSXString","parentStyles","sourceClassName","Source","language","filterProps","ComponentSource","Scene","grid","gridBg","cameras","front","iso","invIso","iso45","invIso45","frontTopLeft","frontTopRight","frontBottomLeft","frontBottomRight","cameraKeyAngle","camera","invAngle3","orbit","inverseOrbitKey","includes","orbitAnimation","keyframes","to","sceneCss","scaleDivCss","Viewport","scale","isOrbiting","reverse","perspective","animationDirection","App","strokeWidth","splitBorderDef","withDefaultBorderDef","defaultBorderDef","hasBorder","edgeList","edge","defaultConfig","majorStep","color","colorStop","config","backgroundColor","lines","halfStroke","repeatingLinearGradient","parallelLines","halfSize","backgroundSize","backgroundAttachment"],"mappings":"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","file":"static/js/main.67d944c8.chunk.js","sourcesContent":["import { flow } from 'fp-ts/lib/function';\nimport { Lens } from 'monocle-ts';\nimport { Context, createContext, useContext } from 'react';\nimport { cssOf, emLineHeight, pxRecord, Style } from 'src/css';\nimport { FontManager } from 'src/font/manager';\nimport { DefaultLineHeightEm } from 'src/font/metrics';\nimport {\n  HMetrics,\n  Measure,\n  Measured,\n  mergeDefaultMeasured,\n} from 'src/font/metrics/measured';\n\nexport const FontContext: Context<FontManager> = createContext(\n  new FontManager(),\n);\n\nexport const useFontContext = () => useContext(FontContext);\n\n/**\n * Compute vertical distance from line top to baseline\n *\n * Requires a `FontContext` in scope.\n *\n * Computed using: `½ × (lineHeight + ascent + lineGap - descent)`\n *\n * @param fontFamily must be loaded into the font manager\n * @param fontSize\n * @param fromTypoMetrics if true, use “TypoMetrics”. If false, uses\n * “WinMetrics” as does Chrome on windows. Default is false\n * @returns distance in pixels\n */\n\nexport const useFontBaseline = (\n  fontFamily: string,\n  fontSize: number,\n  fromTypoMetrics?: boolean,\n): number =>\n  useFontContext().computeBaseLine(fontFamily, fontSize, fromTypoMetrics);\n\nconst metricsToMeasure: Lens<HMetrics, Measure> = Lens.fromProps<HMetrics>()([\n  'text',\n  'fontFamily',\n  'fontSize',\n  'textWidth',\n  'textIndent',\n]);\n\nexport const useFontMetrics = (measured: Partial<Measured>): Measure =>\n  flow(\n    mergeDefaultMeasured,\n    useFontContext().measure,\n    metricsToMeasure.get,\n  )(measured);\n\nconst defaultTextStyle = cssOf('relative', 'noWrap');\n\nexport const useTextBoxMetrics = (measured: Partial<Measured>): Style => {\n  const { fontSize, fontFamily, textWidth: width, textIndent } = useFontMetrics(\n    measured,\n  );\n\n  return {\n    fontFamily,\n    ...defaultTextStyle,\n    ...emLineHeight(DefaultLineHeightEm),\n    ...pxRecord({ width, fontSize, textIndent }),\n  };\n};\n","export const square = <T>(x: T): [T, T] => [x, x];\n","import { pipe } from 'fp-ts/lib/function';\nimport * as AR from 'fp-ts/lib/ReadonlyArray';\nimport { AtRule, Declaration, Expression, Parser } from 'shady-css-parser';\nimport { FetchFont } from 'src/font/types';\n\nconst parser = new Parser();\n\n/**\n * CSS font face rule types are complex and difficult to mock. But we only use a\n * tiny fraction of this to read stylesheet font face definitions. These 4\n * interfaces include exactly what `sheetToFonts` requires. They are extracted\n * from the CSS types.\n */\n\nexport interface CssRule {\n  cssText: string;\n}\n\nexport interface CssFontFaceRule extends CssRule {\n  type: number;\n}\n\nexport interface CssRuleList {\n  [Symbol.iterator](): IterableIterator<CssRule>;\n}\n\nexport interface CssStyleSheet {\n  rules: CssRuleList;\n}\n\nconst parseExpressions = (cssText: string) =>\n  (parser.parse(cssText).rules[0] as AtRule).rulelist?.rules as\n    | Declaration[]\n    | undefined;\n\nconst cleanUrl = (url: string) =>\n    url.replace(/^url\\(\"?/, '').replace(/\"?\\)$/, ''),\n  cleanFamily = (url: string) => url.replaceAll('\"', '');\n\nconst declarationToEntry = (d: Declaration) => [\n  d.name === 'src' ? 'src' : 'fontFamily',\n  pipe((d.value as Expression).text, d.name === 'src' ? cleanUrl : cleanFamily),\n];\n\nconst ruleToFetchFont = ({ cssText }: CssFontFaceRule): FetchFont[] => {\n  const declarations = parseExpressions(cssText);\n  return declarations === undefined\n    ? []\n    : [pipe(declarations, AR.map(declarationToEntry), Object.fromEntries)];\n};\n\nconst isFontFaceRule = (rule: CssRule): rule is CssFontFaceRule =>\n  (rule as CssFontFaceRule).type === 5;\n\n/** Parse all fonts to be fetched from a stylesheet. */\nexport const sheetToFonts = (styleSheet: CssStyleSheet): readonly FetchFont[] =>\n  pipe(\n    styleSheet.rules,\n    Array.from,\n    AR.filter(isFontFaceRule),\n    AR.chain(ruleToFetchFont),\n  );\n","import fontkit from '@pdf-lib/fontkit';\nimport { flow } from 'fp-ts/lib/function';\nimport fs from 'fs';\nimport path from 'path';\nimport { FontManager } from 'src/font/manager';\nimport { FetchedFont, FetchFont } from 'src/font/types';\n\nconst BASE_FONT_PATH = 'src';\n\nconst loadFont = (fetchFont: FetchFont): FetchedFont => ({\n  ...fetchFont,\n  font: flow(\n    path.join,\n    fs.readFileSync,\n    fontkit.create,\n  )(BASE_FONT_PATH, fetchFont.src),\n});\n\n/** Sync read filesystem fonts in Node.js. */\nexport const loadLocalFonts = (families: FetchFont[]): FontManager =>\n  new FontManager(...families.map(loadFont));\n","import * as AR from 'fp-ts/lib/ReadonlyArray';\nimport { pipe } from 'fp-ts/lib/function';\nimport { loadFont } from 'src/font/loader/loadRemote';\nimport { sheetToFonts } from 'src/font/loader/styleSheet';\nimport { FontManager } from 'src/font/manager';\n\nexport * from 'src/font/loader/loadLocal';\n\n/**\n * Loads async all fonts that appear in stylesheets, returns a promise of a\n * `FontManager` with all fonts loaded.\n */\nexport const loadStyleSheetFonts = (): Promise<FontManager> => {\n  const res = pipe(\n    window.document.styleSheets,\n    Array.from,\n    AR.chain(sheetToFonts),\n    AR.map(loadFont),\n    Promise.all.bind(Promise),\n    FontManager.from,\n  );\n  return res;\n};\n\n/** Runs `f` async with a loaded font manager. */\nexport const withFontManager = <T>(\n  f: (fontManager: FontManager) => T,\n): Promise<T> => loadStyleSheetFonts().then(f);\n","export * from 'src/component/App';\nexport * from 'src/component/Scene';\nexport * from 'src/component/ThreeD';\nexport * from 'src/component/TwoD';\nexport * from 'src/component/Demos';\nexport * from 'src/component/Styled';\nexport * from 'src/component/Source';\nexport * from 'src/component/Viewport';\n","import fontkit, { Font } from '@pdf-lib/fontkit';\nimport { FetchedFont, FetchFont } from 'src/font/types';\n\nconst readArrayBuffer = async (blob: Blob): Promise<Buffer> =>\n  new Promise(function (resolve, reject) {\n    const reader = new FileReader();\n    reader.onload = (): void =>\n      resolve(Buffer.from(reader.result as ArrayBuffer));\n    reader.onerror = reject;\n    reader.readAsArrayBuffer(blob);\n  });\n\nexport const loadFont = async (request: FetchFont): Promise<FetchedFont> => {\n  let font: Font;\n  try {\n    const raw = await fetch(request.src),\n      blob = await raw.blob(),\n      buffer = await readArrayBuffer(blob);\n\n    font = fontkit.create(buffer);\n  } catch (e) {\n    e.message = `Failed loading font from \"${request.src}\": ${e.message}`;\n    throw e;\n  }\n  return { ...request, font };\n};\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { App } from 'src/component';\nimport { FontContext, withFontManager } from 'src/font';\nimport 'src/style/fonts.css';\nimport 'src/style/reset.css';\n\nwithFontManager(\n  fontManager =>\n    void ReactDOM.render(\n      <FontContext.Provider value={fontManager}>\n        <App />\n      </FontContext.Provider>,\n      document.getElementById('root'),\n    ),\n);\n","import { FC } from 'react';\nimport { Base, baseStyles } from 'src/component/Base';\nimport { mergeStyles } from 'src/css/merge';\n\n/**\n * A Component placed at some `Point` with some `BorderDef`.\n *\n * Border:\n * @param borderWidth\n * @param borderStyle\n * @param borderColor\n * @param borderEdges\n *\n * Position:\n * @param x\n * @param y\n * @param z\n *\n * 3D:\n * @param is3D\n */\nexport const At: FC<Base> = ({ styles = [], children, ...props }) => (\n  <div className={mergeStyles(...baseStyles(props), ...styles)}>{children}</div>\n);\n","import { FC } from 'react';\nimport { Base, baseStyles } from 'src/component/Base';\nimport { css, cssOf, FlexDir, Style } from 'src/css';\nimport { mergeStyles } from 'src/css/merge';\n\nexport type FlexStyle<S extends Style = Style> = Omit<S, 'display'>;\nexport type NoDirFlexStyle<S extends Style = Style> = Omit<\n  FlexStyle<S>,\n  'flexDirection'\n>;\n\nexport interface Flex<S extends Style = Style> extends Base<FlexStyle<S>> {\n  noGap?: boolean;\n  gap?: number | string;\n  wrap?: boolean;\n  dir?: FlexDir;\n}\n\nexport type NoDirFlex<S extends Style = Style> = Omit<\n  Flex<NoDirFlexStyle<S>>,\n  'dir'\n>;\n\n/** A horizontal/vertical flex container.\n *\n * @param noGap if true, overrides value in `gap` to set `gap=0`. Default is `false`\n * @param gap flex gap in CSS length units. Default is `1ex`\n * @param wrap sets `flex-wrap` if true. Default is `false`\n * @param dir `column` | `row` | `column-reverse` | `row-reverse`. Default is `row`\n */\nexport const Flex: FC<Flex> = ({\n  noGap = false,\n  gap = '1ex',\n  wrap = false,\n  dir,\n  styles = [],\n  children,\n  ...props\n}) => {\n  const className = mergeStyles(\n    !noGap && { padding: gap, gap },\n    wrap && css.flexWrap,\n    cssOf(dir && dir === 'row' ? 'hFlex' : 'vFlex'),\n\n    ...baseStyles(props),\n\n    ...styles,\n  );\n\n  return <div {...{ className }}>{children}</div>;\n};\n\nexport const HFlex: FC<NoDirFlex> = ({ children, ...props }) => (\n  <Flex dir=\"row\" {...props}>\n    {children}\n  </Flex>\n);\n\nexport const VFlex: FC<NoDirFlex> = ({ children, ...props }) => (\n  <Flex dir=\"column\" {...props}>\n    {children}\n  </Flex>\n);\n","import { px } from 'csx';\nimport { pipe } from 'fp-ts/lib/function';\nimport { FC } from 'react';\nimport { BorderBase } from 'src/component/Base';\nimport { NoDirFlexStyle, VFlex } from 'src/component/TwoD/Flex';\nimport { MetricProps, Text } from 'src/component/TwoD/Text';\nimport {\n  addBorderEdges,\n  bgColor,\n  Color,\n  css,\n  fgColor,\n  hPadding,\n  splitEdgeDef,\n  Style,\n  topRightBorderRadius,\n  withDefaultEdgeDef,\n} from 'src/css';\nimport { fallbackFontSize } from 'src/font';\nimport { splitPoint } from 'src/geometry';\nimport { pluck } from 'src/util';\n\nexport interface LabeledProps {\n  labelColor?: Color;\n  labelBgColor?: Color;\n  labelOpacity?: number;\n  labelHPad?: string | 0;\n  innerBorder?: boolean;\n}\n\n/**\n * `Labeled` component is bordered on all edges.\n */\nexport type Labeled<S extends Style = Style> = LabeledProps &\n  MetricProps &\n  BorderBase<NoDirFlexStyle<S>>;\n\n/**\n * A container that adds a label above its children.\n *\n * Label colors:\n * @param labelColor label text color. Default is 'black'\n * @param labelBgColor label text background color. Default is `#fffff0`\n * @param labelOpacity default is `1`\n * @param labelHPad override default horizontal text padding of label\n * @param innerBorder if true, and the label has a border, then a horizontal\n * line is drawn separating the label and its children. Default is `false`\n * @param is3D set to true if children have a Z dimension. Default is\n * `false`\n *\n * Label text props:\n * @param text label text\n * @param fontFamily label font family\n * @param fontSize label font size in pixels, default is `12`\n * @param showMetrics\n * @param fromTypoMetrics\n *\n * Border edge props. `borderEdges` is fixed at `all`.\n * @param borderWidth set to `0` to remove default borders\n * @param borderColor set to `transparent` to remove default borders but leave\n * the space they occupy alone\n * @param borderStyle\n *\n * Point:\n * @param x\n * @param y\n * @param z\n */\nexport const Labeled: FC<Labeled> = ({\n  labelColor = 'black',\n  labelBgColor = '#fffff0',\n  labelOpacity: opacity = 1,\n  labelHPad,\n  innerBorder = false,\n  children,\n  styles = [],\n  ...props\n}) => {\n  const [edgeDef, noEdge] = splitEdgeDef(props),\n    [point, userTextProps] = splitPoint(noEdge),\n    textProps = fallbackFontSize(12)(userTextProps),\n    borderWidth = pipe(withDefaultEdgeDef(edgeDef), pluck('borderWidth'), px);\n\n  const labelStyles = [\n    { opacity, top: borderWidth },\n    innerBorder ? {} : { zIndex: 1 },\n    css.relative,\n    bgColor(labelBgColor),\n    fgColor(labelColor),\n    topRightBorderRadius((3 / 4) * textProps.fontSize),\n    labelHPad != undefined && hPadding(labelHPad),\n  ];\n\n  const textBorder = addBorderEdges(edgeDef)('noBottom');\n\n  return (\n    <VFlex {...point} {...{ styles }} noGap is3D>\n      <Text {...textProps} {...textBorder} styles={labelStyles} />\n      {children}\n    </VFlex>\n  );\n};\n","import { FC } from 'react';\nimport { Base } from 'src/component/Base';\nimport { css, cssOf, OmitPosition } from 'src/css';\nimport { mergeStyles } from 'src/css/merge';\n\nexport type Panel = Base<OmitPosition>;\n\nconst defaultStyle = {\n  ...cssOf('relative', 'minContentWidth'),\n\n  // eslint will not take `$nest` as a key\n  ['$nest']: { '&>*': css.absolute },\n};\n\n/**\n * A layout component for absolutely positioned children. Set `style.top/left`\n * on children to position them.\n */\nexport const Panel: FC<Panel> = ({ children, styles = [], ...props }) => (\n  <div className={mergeStyles(defaultStyle, ...styles)} {...props}>\n    {children}\n  </div>\n);\n","import { BoxThemeKey } from 'src/component/ThreeD/Box/colors';\nimport { defaultHelpers } from 'src/util';\n\nexport interface TotalHasDepth {\n  depth: number;\n  boxThemeKey: BoxThemeKey;\n  opacity: number;\n}\n\nexport type HasDepth = Partial<TotalHasDepth>;\n\nexport const [\n  splitHasDepth,\n  withDefaultHasDepth,\n  defaultHasDepth,\n] = defaultHelpers<HasDepth>({\n  depth: 18,\n  boxThemeKey: 'primary',\n  opacity: 1,\n});\n","import { defaultEdgeDef, TotalEdgeDef } from 'src/css';\nimport {\n  defaultHasDepth,\n  TotalHasDepth,\n} from 'src/component/ThreeD/Box/HasDepth';\nimport { defaultHelpers } from 'src/util';\n\nexport type TotalBorderBox = TotalHasDepth & TotalEdgeDef;\n\nexport type BorderBox = Partial<TotalBorderBox>;\n\nexport const [\n  splitBorderedBox,\n  mergeDefaultBorderBox,\n] = defaultHelpers<BorderBox>({\n  ...defaultHasDepth,\n  ...defaultEdgeDef,\n});\n","export type FaceKey3D = typeof FaceKeys3D[number];\n\nexport type FaceKey = 'front' | FaceKey3D;\n\nexport const FaceKeys3D = ['back', 'top', 'bottom', 'left', 'right'] as const,\n  FaceKeys = ['front', ...FaceKeys3D] as FaceKey[];\n","import { pipe } from 'fp-ts/lib/function';\nimport * as RE from 'fp-ts/ReadonlyArray';\nimport { bgColor, Color, Style } from 'src/css';\nimport { FaceKey, FaceKeys } from 'src/component/ThreeD/Box/types';\n\nexport type BoxTheme = Record<FaceKey, Color>;\nexport type BoxThemes = typeof BoxThemes;\nexport type BoxThemeKey = keyof BoxThemes;\n\ntype BoxColors = [Color, Color, Color, Color, Color, Color];\n\n// front, back, left, right, top, bottom\ntype FaceNum = 0 | 1 | 2 | 3 | 4 | 5;\n\nconst fromTuple = (colors: BoxColors) =>\n    pipe(FaceKeys, RE.zip(colors), Object.fromEntries) as BoxTheme,\n  mapColors = (f: (idx: FaceNum) => Color) =>\n    fromTuple(\n      pipe(\n        RE.range(0, 5),\n        RE.map(idx => f(idx as FaceNum)),\n      ) as BoxColors,\n    );\n\nconst idxToPercent = (idx: number) => Math.round((100 * (6 - idx)) / 6);\n\nconst BoxThemes = {\n  primary: fromTuple(['white', 'purple', 'orange', 'green', 'red', 'yellow']),\n  grayscale: mapColors(i => `hsl(0deg,0%,${idxToPercent(i)}%)`),\n  transparent: mapColors(() => 'transparent'),\n  white: mapColors(() => 'white'),\n  yellowOrange: mapColors(i =>\n    i === 0 ? '#ffff00' : i === 1 ? '#eeff44' : '#ffcc00',\n  ),\n} as const;\n\nexport const boxThemes = Object.keys(BoxThemes) as BoxThemeKey[],\n  boxThemeColor = (key: BoxThemeKey) => (face: FaceKey): Color =>\n    BoxThemes[key][face],\n  boxThemeStyle = (key: BoxThemeKey, face: FaceKey): Style =>\n    pipe(face, boxThemeColor(key), bgColor);\n","import { FC } from 'react';\nimport {\n  BorderBox,\n  mergeDefaultBorderBox,\n} from 'src/component/ThreeD/Box/BorderBox';\nimport { boxThemeStyle } from 'src/component/ThreeD/Box/colors';\nimport { FaceKey, FaceKey3D } from 'src/component/ThreeD/Box/types';\nimport { allBordersCss, cssOf, px, rotateBy, Style, translate } from 'src/css';\nimport { Axis, ThreeDAxis } from 'src/geometry';\nimport { style } from 'typestyle';\n\ntype Transforms = [ThreeDAxis, 'top' | 'left'] | [ThreeDAxis];\n\nconst Transforms: Record<FaceKey3D, Transforms> = {\n    back: ['z'],\n    top: ['x'],\n    bottom: ['x', 'top'],\n    left: ['y'],\n    right: ['y', 'left'],\n  },\n  defaultFaceStyle = cssOf('absolute', 'leftTopOrigin');\n\nconst layout = (depth: number, borderWidth: number) => (\n  face: FaceKey3D,\n): Style => {\n  const [[axis, shift], pad] = [Transforms[face], depth + 2 * borderWidth],\n    byAxis = (flag: boolean) => (flag ? px(pad) : '100%');\n\n  return {\n    transform: [\n      translate({ z: px(-1 * pad) }),\n      rotateBy(axis)(90 * Axis.match(axis)(1, -1, 0)),\n    ].join(' '),\n\n    ...{ width: byAxis(Axis.isY(axis)), height: byAxis(Axis.isX(axis)) },\n    ...(shift !== undefined ? { [shift]: '100%' } : {}),\n  };\n};\n\nexport const faceStyle = ({ addBg = false, face, ...borderBox }: Face) => {\n  const {\n    depth,\n    boxThemeKey,\n    borderWidth,\n    opacity,\n    ...borderDef\n  } = mergeDefaultBorderBox(borderBox);\n\n  return style(\n    addBg && boxThemeStyle(boxThemeKey, face),\n    opacity !== undefined && { opacity },\n    allBordersCss({ borderWidth, ...borderDef }),\n    ...(face !== 'front'\n      ? [defaultFaceStyle, layout(depth, borderWidth)(face)]\n      : []),\n  );\n};\n\ninterface Face extends BorderBox {\n  face: FaceKey;\n  addBg?: boolean;\n}\n\n/**\n * One of the six faces of a box\n *\n * Face style\n * @param depth Box size on Z-axis in pixel. The box will be drawn so that\n * the back face will appear to be extruded `depth` pixels to the back\n * @param boxThemeKey a key from the box themes dictionary. Sets the face\n * color scheme. Default is `basic colors`\n * @param opacity\n * @param addBg If true, we add background color from the box theme to the\n * face. Default is false\n *\n * Wireframe line style\n * @param borderColor\n * @param borderWidth\n * @param borderStyle\n */\nexport const Face: FC<Face> = ({ children, ...props }) => (\n  <div className={faceStyle(props)}>{children}</div>\n);\n","import { FC } from 'react';\nimport { BorderBase } from 'src/component/Base';\nimport { Face } from 'src/component/ThreeD/Box/Face';\nimport { HasDepth } from 'src/component/ThreeD/Box/HasDepth';\nimport { FaceKeys3D } from 'src/component/ThreeD/Box/types';\nimport { At } from 'src/component/TwoD';\nimport { cssOf, OmitPosition, Style } from 'src/css';\nimport { splitPoint } from 'src/geometry';\n\nexport interface Box<S extends Style = Style>\n  extends BorderBase<OmitPosition<S>>,\n    HasDepth {\n  addFrontBg?: boolean;\n}\n\nconst defaultCss = cssOf('relative', 'threeD');\n\n/** Actually an `Irregular Rectangular Prism`. */\nexport const Box: FC<Box> = ({\n  addFrontBg: addBg,\n  children,\n  styles = [],\n  ...props\n}) => {\n  const [point, faceProps] = splitPoint(props);\n\n  return (\n    <At {...point} styles={[defaultCss, ...styles]}>\n      <Face face=\"front\" {...{ addBg }} {...faceProps}>\n        {children}\n      </Face>\n      {FaceKeys3D.map(face => (\n        <Face addBg {...{ face }} {...faceProps} key={face} />\n      ))}\n    </At>\n  );\n};\n","import { px } from 'csx';\nimport { FC } from 'react';\nimport { Box } from 'src/component/ThreeD/Box/component';\nimport {\n  HasDepth,\n  splitHasDepth,\n  withDefaultHasDepth,\n} from 'src/component/ThreeD/Box/HasDepth';\nimport { Labeled } from 'src/component/TwoD';\nimport { splitEdgeDef, withDefaultEdgeDef } from 'src/css';\nimport { splitPoint } from 'src/geometry';\n\nexport interface LabeledBox extends Omit<Labeled, 'is3D'>, HasDepth {\n  zLevel?: number;\n}\n\n/** A container that renders a label above its children and a rectangular prism\n * behind them\n *\n * @param zLevel multiplied by `depth` and added to the element Z coordinate.\n * Default is 0. This will render the front face flat on the parent element.\n * Set to an integer `n`, to raise the element by the height of the box sides\n * times `n`\n */\nexport const LabeledBox: FC<LabeledBox> = ({\n  zLevel = 0,\n  children,\n  styles = [],\n  ...props\n}) => {\n  const [userEdgeDef, noEdgeDef] = splitEdgeDef(props),\n    [{ z = '0px', ...point }, noPoint] = splitPoint(noEdgeDef),\n    [userBoxDef, labeled] = splitHasDepth(noPoint);\n\n  const { borderWidth, ...edgeDef } = withDefaultEdgeDef(userEdgeDef),\n    edgeProps = { borderWidth, ...edgeDef };\n\n  const { depth, ...boxDef } = withDefaultHasDepth(userBoxDef),\n    boxProps = { depth, ...boxDef, ...edgeProps };\n\n  const labeledProps = {\n    ...edgeProps,\n    ...labeled,\n    ...point,\n    z: `calc(${z} + ${px(zLevel * depth + 2 * borderWidth)})`,\n  };\n\n  return (\n    <Labeled {...labeledProps} {...{ styles }} is3D>\n      <Box addFrontBg {...boxProps}>\n        {children}\n      </Box>\n    </Labeled>\n  );\n};\n","import { FC } from 'react';\nimport { LabeledBox } from 'src/component/ThreeD/LabeledBox';\nimport { splitText, Text } from 'src/component/TwoD/Text';\n\nexport type LabeledTextBox = LabeledBox & { labelText?: string };\n\n/** `Text` inside a `LabeledBox` */\nexport const LabeledTextBox: FC<LabeledTextBox> = ({\n  labelText = 'label',\n  children,\n  styles = [],\n  ...props\n}) => {\n  const [{ text, ...textProps }, noText] = splitText(props);\n\n  return (\n    <LabeledBox text={labelText} {...noText} {...textProps} {...{ styles }}>\n      <Text {...textProps} {...{ text }} />\n      {children}\n    </LabeledBox>\n  );\n};\n","import { FC } from 'react';\nimport { BorderBox } from 'src/component/ThreeD/Box/BorderBox';\nimport { LabeledBox } from 'src/component/ThreeD/LabeledBox';\nimport { LabeledTextBox } from 'src/component/ThreeD/LabeledTextBox';\nimport { Flex } from 'src/component/TwoD';\nimport { FlexDir } from 'src/css';\n\ninterface Leaf {\n  args: LabeledTextBox;\n}\n\nexport interface Branch {\n  args: BorderBox;\n  text: string;\n  dir: FlexDir;\n  nodes: readonly Node[];\n}\n\ninterface TwoDBranch {\n  dir: FlexDir;\n  nodes: readonly Node[];\n}\n\ntype Node = Leaf | Branch | TwoDBranch;\ntype LeafFn = (args: LabeledTextBox) => Leaf;\ntype LeafKey = typeof leafKeys[number];\ntype CurriedLeafFn = (common?: Partial<LabeledBox>) => (text: string) => Leaf;\ntype NewLeaf = Record<LeafKey, CurriedLeafFn> & LeafFn;\n\nconst leafKeys = ['link', 'textField', 'fontPicker'] as const,\n  isLeaf = (x: Node): x is Leaf => !('dir' in x),\n  isBranch = (x: Node): x is Branch => 'dir' in x && 'text' in x,\n  isTwoDBranch = (x: Node): x is TwoDBranch => !('text' in x);\n\nexport const matchNode = (\n  f: FC<Leaf>,\n  g: FC<Branch>,\n  h: FC<TwoDBranch>,\n  empty: JSX.Element,\n) => (node: Node) =>\n  isLeaf(node)\n    ? f(node)\n    : isBranch(node)\n    ? g(node)\n    : isTwoDBranch(node)\n    ? h(node)\n    : () => empty;\n\nconst renderNode = (node: Node, idx: number) =>\n  matchNode(\n    leaf => <Leaf {...leaf} key={idx} />,\n    branch => <Branch {...branch} key={idx} />,\n    twoDBranch => <TwoDBranch {...twoDBranch} key={idx} />,\n    <></>,\n  )(node);\n\nexport const Leaf: FC<Leaf> = ({ args }) => <LabeledTextBox {...args} />,\n  TwoDBranch: FC<TwoDBranch> = ({ nodes, dir }) => (\n    <Flex {...{ dir }} styles={[{ paddingTop: 0 }]}>\n      {nodes.map(renderNode)}\n    </Flex>\n  ),\n  Branch: FC<Branch> = ({ nodes, dir, args, ...props }) => (\n    <LabeledBox {...props} {...args}>\n      <Flex {...{ dir }}>{nodes.map(renderNode)}</Flex>\n    </LabeledBox>\n  );\n\n/** * 3D tree leaf */\nexport const leaf: NewLeaf = (() => {\n    const fn: LeafFn = args => ({ args }),\n      res = fn as NewLeaf,\n      curryFn = (labelText: string) => (common: Partial<LabeledBox> = {}) => (\n        text: string,\n      ) => leaf({ labelText, text, ...common });\n\n    res.link = curryFn('Link');\n    res.textField = curryFn('TextField');\n    res.fontPicker = curryFn('FontPicker');\n\n    return res;\n  })(),\n  curryLeaf = (common: LabeledTextBox) => leafKeys.map(k => leaf[k](common));\n\n/**\n * 1. `rowBranch` - 3D horizontal flex tree branch\n * 1. `columnBranch` - 3D vertical flex tree branch\n * 1. `vertical` - 2D vertical flex tree branch\n */\nexport const rowBranch = (args: Partial<BorderBox>) => (\n    text: string,\n    ...nodes: Node[]\n  ): Branch => ({\n    text,\n    nodes,\n    dir: 'row',\n    args,\n  }),\n  columnBranch = (args: Partial<BorderBox>) => (\n    text: string,\n    ...nodes: Node[]\n  ): Branch => ({\n    text,\n    nodes,\n    dir: 'column',\n    args,\n  }),\n  vertical = (...nodes: Node[]) => ({ nodes, dir: 'column' as FlexDir });\n","import { curry2 } from 'fp-ts-std/Function';\nimport { eqString } from 'fp-ts/lib/Eq';\n\nexport type TwoDAxis = 'x' | 'y';\nexport type ThreeDAxis = 'x' | 'y' | 'z';\nexport type Vec3<T = number> = Record<ThreeDAxis, T>;\n\nexport type Angle3 = Partial<Vec3>;\n\nexport const ThreeDAxis: ThreeDAxis[] = ['x', 'y', 'z'];\n\nexport const ZeroAngle3: Angle3 = { x: 0, y: 0, z: 0 };\n\nconst axisEq = curry2(eqString.equals),\n  axisIs = { isX: axisEq('x'), isY: axisEq('y'), isZ: axisEq('z') };\n\nexport const Axis = {\n  ...axisIs,\n  match: (axis: ThreeDAxis) => <T>(x: T, y: T, z: T): T =>\n    axis === 'x' ? x : axis === 'y' ? y : z,\n} as const;\n\nexport const invDeg = (deg: number): number =>\n  deg % 360 === 0 ? Math.abs(360 - deg) : (deg - Math.sign(deg) * 360) % 360;\n","import { Vec3 } from 'src/geometry/Axis';\nimport { split } from 'src/util';\n\nexport type Point = Partial<Vec3<number | string>>;\n\nexport const hasDefined = ({ x, y, z }: Point) =>\n    x !== undefined || y !== undefined || z !== undefined,\n  splitPoint = split(['x', 'y', 'z']);\n","import { flip } from 'fp-ts-std/Function';\nimport * as RA from 'fp-ts/Array';\nimport { flow, pipe } from 'fp-ts/lib/function';\nimport * as RE from 'fp-ts/Record';\nimport { tupled } from 'fp-ts/lib/function';\nimport { css, cssClasses, CssKey } from 'src/css/lib';\nimport { Style } from 'src/css/types';\nimport { mergeObjects, picks, pluck } from 'src/util';\nimport { Optional } from 'src/util/types';\nimport { classes, style } from 'typestyle';\n\nexport const ucFirst = (s: string) => s.charAt(0).toUpperCase() + s.slice(1);\n\n// csx functions that suffix units (E.g. “em()”) returns types incompatible with\n// TypeStyle NestedCssProperties\ntype AddUnit = (v: number) => string & {};\nexport const px: AddUnit = v => `${v.toFixed(3)}px`;\nexport const em: AddUnit = v => `${v.toFixed(1)}em`;\n\n/** Project a numeric record into a record of CSS `px` values */\nexport const pxRecord = RE.map(px);\n/** Project a numeric record into a record of CSS `em` values */\nexport const emRecord = RE.map(em);\n\n/** Filter false and undefined values from a style list */\nexport const cleanStyles = (styles: Optional<Style>[]) =>\n  styles.filter(x => x !== undefined && x !== false) as Style[];\n\n/**\n * Convert a list of style keys from `src/css/lib:css` into a `Style`\n *\n * Example:\n * `se\n * ``\n * cssOf('relative', 'noWrap') ≡ {\n *   position:   relative,\n *   whitespace: noWrap,\n * }\n * ```\n */\nexport const cssOf = <K extends CssKey>(...keys: K[]): Style =>\n  pipe(css, picks(...keys), Object.values, tupled(mergeObjects));\n\n/**\n * Same as `cssOf` but returns a generated CSS class names instead of a\n * `Style`\n */\nexport const classOf = <K extends CssKey>(...keys: K[]): string =>\n  pipe(keys, pipe(cssClasses, flip(pluck), RA.map), classes);\n\n/**\n * Curried version of `typestyle/style`: takes two lists of styles and returns\n * a generated CSS class name. The lists may include `undefined` or `false`\n * values. They will be filtered.\n */\nexport const defaultCss = (...head: Optional<Style>[]) => (\n  ...tail: Optional<Style>[]\n): string => style(...head, ...tail);\n\n/**\n * Same as `defaultCss` but returns a generated CSS class name instead of a\n * `Style`\n */\nexport const defaultClass = flow(cssOf, defaultCss);\n","export * from 'src/font/loader';\nexport * from 'src/font/manager';\nexport * from 'src/font/metrics';\nexport * from 'src/font/types';\nexport * from 'src/font/useFontMetrics';\n","import { defaultHelpers } from 'src/util';\n\n/**\n * A string of text and its font size/family. Members of this type can be\n * measured for their font metrics by a font manager, assuming it has loaded\n * the given font family.\n */\nexport interface Measured {\n  fontFamily: string;\n  fontSize: number;\n  text: string;\n}\n\nexport type MeasuredKey = keyof Measured;\n\n/** The result of the “measure text” operation */\nexport interface Measure extends Measured {\n  textWidth: number;\n  textIndent: number;\n}\n\n/** Full horizontal font metrics of the measured text */\nexport interface HMetrics extends Measure {\n  minX: number;\n  maxX: number;\n  bearingRight: number;\n  advanceWidth: number;\n}\n\nexport const [\n  splitMeasured,\n  mergeDefaultMeasured,\n  defaultMeasured,\n  measuredKeys,\n] = defaultHelpers<Partial<Measured>>({\n  fontFamily: 'Roboto',\n  fontSize: 16,\n  text: ' ',\n});\n\n/** Set a default font size on a partial `Measured` unless it has one */\nexport const fallbackFontSize = (fontSize: number) => (\n  measured: Partial<Measured>,\n) => ({ fontSize, ...measured } as Partial<Measured> & { fontSize: number });\n","export * from 'src/css/border';\nexport * from 'src/css/builders';\nexport * from 'src/css/grid';\nexport * from 'src/css/lib';\nexport * from 'src/css/safeStyles';\nexport * from 'src/css/types';\nexport * from 'src/css/util';\nexport * from 'src/css/valueTypes';\n","import { Font } from '@pdf-lib/fontkit';\nimport * as RA from 'fp-ts/Array';\nimport { pipe } from 'fp-ts/lib/function';\nimport {} from 'fp-ts/lib/Record';\nimport {\n  computeTypoBaseLine,\n  computeWinBaseLine,\n  measureText,\n} from 'src/font/metrics';\nimport { HMetrics, Measured } from 'src/font/metrics/measured';\nimport { FetchedFont } from 'src/font/types';\nimport { pluck } from '../util/Object';\n\nexport class FontManager {\n  private cache: Map<string, FetchedFont> = new Map();\n\n  constructor(...loadedFonts: FetchedFont[]) {\n    loadedFonts.forEach(loadedFont => {\n      this.cache.set(loadedFont.fontFamily, loadedFont);\n    });\n  }\n\n  get = (family: string): Font => {\n    if (family === undefined)\n      throw new Error('Requested font but family name is undefined.');\n\n    const res = this.cache.get(family);\n    if (res === undefined)\n      throw new Error(\n        `No font found for family name “${family}”. ` +\n          (this.cache.size\n            ? `These families have been loaded: ${this.families\n                .map(f => `“${f}”`)\n                .join(', ')}`\n            : 'No font families have been loaded.'),\n      );\n    return res.font;\n  };\n\n  get fonts(): FetchedFont[] {\n    return Array.from(this.cache.values());\n  }\n\n  get families(): string[] {\n    return pipe('fontFamily', pluck, RA.map)(this.fonts);\n  }\n\n  measure = (measured: Measured): HMetrics =>\n    pipe(measured.fontFamily, this.get, measureText)(measured);\n\n  /**\n   * Distance in pixels from top of text line (1.5em `line-height`) to baseline\n   *\n   */\n  computeBaseLine = (\n    fontFamily: string,\n    fontSize: number,\n    fromTypoMetrics = false,\n  ): number => {\n    const font = this.get(fontFamily),\n      baseline = (fromTypoMetrics ? computeTypoBaseLine : computeWinBaseLine)(\n        font,\n      );\n\n    return (fontSize / font.unitsPerEm) * baseline;\n  };\n\n  static from = async (\n    loadedFonts: Promise<FetchedFont[]>,\n  ): Promise<FontManager> => new FontManager(...(await loadedFonts));\n}\n","import * as REC from 'fp-ts/Record';\nimport { style } from 'typestyle';\n\nconst atomic = {\n  relative: { position: 'relative' },\n  absolute: { position: 'absolute', top: 0, left: 0 },\n  borderBox: { boxSizing: 'border-box' },\n  contentBox: { boxSizing: 'content-box' },\n\n  w100: { width: '100%' },\n  h100: { height: '100%' },\n  minContentWidth: { width: 'min-content' },\n\n  centerText: { textAlign: 'center' },\n\n  hFlex: { display: 'flex', flexDirection: 'row' },\n  vFlex: { display: 'flex', flexDirection: 'column' },\n  flex1: { flex: 1 },\n  flexWrap: { flexWrap: 'wrap' },\n  alignBaseline: { alignItems: 'baseline' },\n  alignTop: { alignItems: 'flex-start' },\n  alignBottom: { alignItems: 'flex-end' },\n  stretch: { alignItems: 'stretch' },\n\n  noOverflow: { overflow: 'hidden' },\n  autoOverflow: { overflow: 'auto' },\n  noWrap: { whiteSpace: 'nowrap' },\n\n  whiteBg: { background: 'white' },\n  blackBorder: { border: '1px solid black' },\n\n  centerOrigin: { transformOrigin: 'center' },\n  leftTopOrigin: { transformOrigin: 'left top' },\n  threeD: { transformStyle: 'preserve-3d' },\n  twoD: { transformStyle: 'flat' },\n\n  play: { animationPlayState: 'running' },\n  pause: { animationPlayState: 'paused' },\n} as const;\n\nconst wh100 = { ...atomic.w100, ...atomic.h100 };\n\nexport const composed = {\n  wh100,\n  absWh100: { ...wh100, ...atomic.absolute },\n  relWh100: { ...wh100, ...atomic.relative },\n\n  bwBorder: { ...atomic.whiteBg, ...atomic.blackBorder },\n} as const;\n\nexport const css = { ...atomic, ...composed } as const,\n  cssClasses: Record<CssKey, string> = REC.map(style)(css);\n\nexport type CssKey = keyof typeof css;\n","import { flip } from 'fp-ts-std/Function';\nimport { flow, pipe, tupled } from 'fp-ts/lib/function';\nimport * as RA from 'fp-ts/ReadonlyArray';\nimport { Style, StyleKey } from 'src/css';\nimport { cleanStyles } from 'src/css/util';\nimport { mergeObjectsT, Optional, split, unaryObject } from 'src/util';\nimport { style } from 'typestyle';\n\nconst mergeEntry = (o1: Style, o2: Style) => <K extends StyleKey>(\n  k: K,\n): Style => {\n  const [v1, v2] = [o1[k], o2[k]],\n    obj = flip(unaryObject)(k);\n\n  return v1 === undefined\n    ? v2 === undefined\n      ? {}\n      : obj(`${v2}`) // -v₁ +v₂\n    : v2 === undefined\n    ? obj(`${v1}`) // +v₁ -v₂\n    : obj([v1, v2].join(k === 'transform' ? ' ' : ','));\n};\n\nconst mergeKeys = ['background', 'boxShadow', 'transform'] as const;\n\n/**\n * Merge 2 styles paying special attention to lossless merging of values that\n * can be stacked, like `background` and `transform`\n *\n * @param s1\n * @param s2\n * @returns merged style\n *\n * #### Limitations\n *\n * 1. Overrides and information loss is implicit for properties not merged.\n * E.g.: if `display` is present in both styles, the 1st is silently discarded.\n * Most of the time this is desired behavior\n * 1. Sometimes you actually want override behavior on properties that merge\n */\nexport const mergeCssPair = <S1 extends Style, S2 extends Style>(\n  s1: S1,\n  s2: S2,\n): Style => {\n  const [[toMerge1, noMerge1], [toMerge2, noMerge2]] = pipe(\n    [s1, s2],\n    pipe(mergeKeys, split, RA.map),\n  );\n  return {\n    ...noMerge1,\n    ...noMerge2,\n    ...pipe(\n      mergeKeys,\n      flow(mergeEntry, RA.map)(toMerge1, toMerge2),\n      mergeObjectsT,\n    ),\n  };\n};\n\n/**\n * Like mergeCssPair but takes N styles and filters `false` & `undefined` from\n * style list before merging\n */\nexport const mergeCss = (...styles: Optional<Style>[]): Style =>\n  pipe(styles, cleanStyles, RA.reduce({}, mergeCssPair));\n\n/**\n * Like mergeCss but returns the generated class name instead of the merged\n * style\n */\nexport const mergeStyles = (...styles: Optional<Style>[]): string =>\n  flow(tupled(mergeCss), style)(styles);\n","import { Font } from '@pdf-lib/fontkit';\nimport { divide, multiply } from 'fp-ts-std/Number';\nimport { flow, pipe } from 'fp-ts/lib/function';\nimport * as RE from 'fp-ts/ReadonlyRecord';\nimport {\n  HMetrics,\n  Measured,\n  mergeDefaultMeasured,\n} from 'src/font/metrics/measured';\n\nexport const measureText = (font: Font) => (\n  measured: Partial<Measured> = {},\n): HMetrics => {\n  const totalMeasured = mergeDefaultMeasured(measured),\n    [{ fontSize, text }, { unitsPerEm }] = [totalMeasured, font],\n    { advanceWidth, bbox } = font.layout(text),\n    { minX, maxX } = bbox,\n    uemToPx = flow(multiply(fontSize), divide(unitsPerEm)),\n    textWidth = maxX - minX;\n\n  return {\n    ...totalMeasured,\n    ...pipe(\n      {\n        advanceWidth,\n        textWidth,\n        minX,\n        maxX,\n        textIndent: -1 * minX,\n        bearingRight: advanceWidth - textWidth,\n      },\n      RE.map(uemToPx),\n    ),\n  };\n};\n","import { Font } from '@pdf-lib/fontkit';\n\nexport const DefaultLineHeightEm = 1.5;\n\nconst Os2Keys = [\n  'typoAscender',\n  'typoDescender',\n  'typoLineGap',\n  'winDescent',\n  'winAscent',\n] as const;\n\ntype Os2Data = Record<typeof Os2Keys[number], number>;\n\n/** Fontkit typescript declarations are missing these. */\ndeclare module '@pdf-lib/fontkit' {\n  export interface Font {\n    os2: Os2Data;\n  }\n}\n\nconst readOs2 = (font: Font): Os2Data => font['OS/2'] as any;\n\nexport const computeWinBaseLine = (\n  font: Font,\n  lineHeight = DefaultLineHeightEm,\n): number => {\n  const { lineGap, unitsPerEm: uem } = font,\n    { winDescent, winAscent } = readOs2(font);\n  return (lineHeight * uem + winAscent + lineGap - winDescent) / 2;\n};\n\nexport const computeTypoBaseLine = (\n  font: Font,\n  lineHeight = DefaultLineHeightEm,\n): number => {\n  const { unitsPerEm: uem } = font,\n    { typoAscender, typoLineGap, typoDescender } = readOs2(font);\n  return (lineHeight * uem + typoAscender + typoLineGap + typoDescender) / 2;\n};\n","import { FC } from 'react';\nimport { borderCss, defaultClass, heightPx } from 'src/css';\nimport { useFontBaseline } from 'src/font';\n\nexport const className = defaultClass('absolute', 'w100'),\n  baselineBorder = {\n    borderColor: '#ff0000ff',\n    borderStyle: 'dashed',\n    borderEdges: 'bottom',\n  } as const;\n\nexport interface MetricGuides {\n  fontFamily: string;\n  fontSize: number;\n  fromTypoMetrics?: boolean;\n}\n\nexport const MetricGuides: FC<MetricGuides> = ({\n  fontFamily,\n  fontSize,\n  fromTypoMetrics = false,\n}) => (\n  <div\n    className={className(\n      heightPx(useFontBaseline(fontFamily, fontSize, fromTypoMetrics)),\n      borderCss({ ...baselineBorder, borderWidth: fontSize / 16 }),\n    )}\n  />\n);\n","import { pipe } from 'fp-ts/lib/function';\nimport { FC } from 'react';\nimport { Base, baseStyles } from 'src/component/Base';\nimport { cssOf, hPadding, OmitText, px, Style } from 'src/css';\nimport { mergeStyles } from 'src/css/merge';\nimport {\n  Measured,\n  mergeDefaultMeasured,\n  splitMeasured,\n  useTextBoxMetrics,\n} from 'src/font';\n\nexport type TextStyle<S extends Style = Style> = OmitText<S>;\n\nexport type PlainText<S extends Style = Style> = Partial<Measured> &\n  Base<TextStyle<S>>;\n\n// Explicitly override box-sizing in order to avoid having to measure border\n// width when measuring text\nconst defaultStyle = cssOf('contentBox');\n\n/**\n * A text div with tighter horizontal padding.\n *\n * A text div with zero horizontal padding will still show some distance\n * between the edge of some characters and the element content edge. This\n * breaks requirements such as horizontally aligned text. The space is the\n * `advance` of the head/final glyphs, used to space out glyphs in a word. We\n * _do_ want this between glyphs, but _not_ at the head/final glyph.\n *\n * This code exists until CSS gets the required font metrics. If you set\n * horizontal padding to zero, then that will be precisely the distance between\n * the text and the element edge, regardless of the glyph, font family or font\n * size. Uses the font metrics to compute the `advance` of the head/last glyphs,\n * then clips and shifts the text accordingly.\n *\n * Adds ownership of the style keys:\n * 1. `width`\n * 1. `height`\n * 1. `fontFamily`\n * 1. `fontSize`\n * 1. `textIndent`\n * 1. `lineHeight\n *\n * Text:\n * @param fontFamily must be loaded by the font manager\n * @param fontSize in pixels\n * @param text\n *\n * Border:\n * @param borderWidth\n * @param borderColor\n * @param borderStyle\n * @param borderEdges set to any value other than `none` to show a border on\n * the specified edges. Default is show no border\n *\n * Position:\n * @param x\n * @param y\n * @param z\n *\n * 3D:\n * @param is3D\n */\nexport const PlainText: FC<PlainText> = ({\n  children,\n  styles = [],\n  ...props\n}) => {\n  const [measured, base] = splitMeasured(props),\n    textDef = mergeDefaultMeasured(measured),\n    { text, fontSize } = textDef;\n\n  const className = mergeStyles(\n    ...baseStyles(base),\n    defaultStyle,\n    useTextBoxMetrics(textDef),\n    pipe(fontSize / 2, px, hPadding),\n    ...styles,\n  );\n\n  return (\n    <div {...{ className }}>\n      {text}\n      {children}\n    </div>\n  );\n};\n","import { FC } from 'react';\nimport { MetricGuides } from 'src/component/TwoD/Text/MetricGuides';\nimport { PlainText } from 'src/component/TwoD/Text/PlainText';\nimport { Style } from 'src/css';\nimport { mergeDefaultMeasured } from 'src/font/metrics/measured';\n\nexport interface MetricText<S extends Style = Style> extends PlainText<S> {\n  fromTypoMetrics?: boolean;\n}\n\n/**\n * A `PlainText` component but with an overlay showing some font metrics:\n *\n * * Baseline\n * * Left/right edges of the measured text\n *\n * @param fromTypoMetrics uses `WinMetrics` by default. If this flag is true\n * then font metrics will be read from the font `OS/2` table `TypoMetrics`\n * entries as used on Linux Chrome.\n */\nexport const MetricText: FC<MetricText> = ({\n  fromTypoMetrics,\n  children,\n  ...props\n}) => {\n  const { fontFamily, fontSize } = mergeDefaultMeasured(props);\n  return (\n    <PlainText {...props}>\n      <MetricGuides {...{ fromTypoMetrics, fontFamily, fontSize }} />\n      {children}\n    </PlainText>\n  );\n};\n","import { FC } from 'react';\nimport { Base } from 'src/component/Base';\nimport { MetricText } from 'src/component/TwoD/Text/MetricText';\nimport { PlainText, TextStyle } from 'src/component/TwoD/Text/PlainText';\nimport { Style } from 'src/css';\nimport { Measured, measuredKeys } from 'src/font/metrics/measured';\nimport { split } from 'src/util';\n\nexport * from 'src/component/TwoD/Text/MetricGuides';\nexport * from 'src/component/TwoD/Text/MetricText';\nexport * from 'src/component/TwoD/Text/PlainText';\n\n/**\n * The type of props used by components that show text and possibly font\n * metrics\n **/\nexport interface MetricProps extends Partial<Measured> {\n  showMetrics?: boolean;\n  fromTypoMetrics?: boolean;\n}\n\nexport type Text<S extends Style = Style> = Base<TextStyle<S>> & MetricProps;\n\nexport const textKeys = [\n    'showMetrics',\n    'fromTypoMetrics',\n    ...measuredKeys,\n  ] as const,\n  splitText = split(textKeys);\n\n/**\n * A `PlainText` component that optionally shows some font metrics\n *\n * Font metrics:\n * @param showMetrics  - set to `true` to overlay the baseline ruler over the\n * component. Default is false\n * @param fromTypoMetrics - uses `WinMetrics` by default. If this flag is true\n * then font metrics will be read from the `OS/2` table `TypoMetrics`\n * entries. Default is false\n *\n * Text props:\n * @param text\n * @param fontFamily\n * @param fontSize\n *\n * Border props:\n * @param borderWidth\n * @param borderColor\n * @param borderStyle\n * @param borderEdges\n *\n * Point translate props:\n * @param x\n * @param y\n * @param z\n */\nexport const Text: FC<Text> = ({ showMetrics = false, children, ...props }) => {\n  const TextTag = showMetrics ? MetricText : PlainText;\n\n  return <TextTag {...props}>{children}</TextTag>;\n};\n","import { flow } from 'fp-ts/lib/function';\nimport { Styled } from 'src/component/Styled';\nimport {\n  borderCss,\n  BorderDef,\n  css,\n  OmitBase,\n  Style,\n  transform,\n  translate,\n} from 'src/css';\nimport { hasDefined, Point, splitPoint } from 'src/geometry';\nimport { Optional } from 'src/util';\n\n/**\n * Props for components that have:\n * 1. A list of styles of type `Optional<S>`\n * 1. 3D coordinates where they will be placed when rendered\n * 1. A border on the edges defined by `borderEdges`\n * 1. A boolean property `is3D`. If true, children can be transformed on the Z\n * dimension. Sets CSS `transform-style` to `preserve-3d`\n *\n * Owns the style keys:\n * 1. `border`, `border-(top|bottom|left|right)`,\n * `border-(top|bottom|left|right)-(style|width|color)`\n * 1. `transform-style`\n */\nexport interface Base<S extends Style = Style>\n  extends Styled<OmitBase<S>>,\n    Point,\n    BorderDef {\n  is3D?: boolean;\n}\n\n/** Same as `Base`, except the border, if existing, is on _all_ sides */\nexport type BorderBase<S extends Style = Style> = Omit<Base<S>, 'borderEdges'>;\n\n/** Convert `Base` props into the correct styles */\nexport const baseStyles = ({\n  is3D,\n  ...props\n}: Omit<Base, 'styles'>): Optional<Style>[] => {\n  const [point, borderDef] = splitPoint(props);\n\n  return [\n    hasDefined(point) && flow(translate, transform)(point),\n    borderCss(borderDef),\n    is3D && css.threeD,\n  ];\n};\n","export const Demos = () => {};\n\nimport { FC, ReactElement } from 'react';\nimport { Box, LabeledBox, LabeledTextBox } from 'src/component/ThreeD';\nimport { HFlex, Labeled, Text, VFlex } from 'src/component/TwoD';\nimport { bgColor, css, fontSizePx, heightPx, px, widthPx } from 'src/css';\nimport { style } from 'typestyle';\n\nconst plainText: Text = { showMetrics: true, text: 'HELLO' };\nconst labeled = { ...plainText, text: 'Label' };\nconst labeledText = { ...plainText, labelText: 'Label' };\nconst hello = (props?: Text) => <Text {...plainText} {...props} />;\n\nexport interface Demo {\n  name: string;\n  component: ReactElement;\n}\n\nexport const demos = [\n  { name: 'Text + baseline', component: hello() },\n  { name: 'Text + border', component: hello({ borderEdges: 'all' }) },\n  { name: 'hPad = 0', component: hello({ borderEdges: 'all' }) },\n  {\n    name: 'Labeled',\n    component: (\n      <Labeled {...labeled}>\n        {hello({ borderEdges: 'all', styles: [css.whiteBg] })}\n      </Labeled>\n    ),\n  },\n  { name: 'Box', component: <Box>HELLO</Box> },\n  { name: 'Box with no border', component: <Box borderWidth={0}>HELLO</Box> },\n  { name: 'Box addFrontBg flag', component: <Box addFrontBg>HELLO</Box> },\n  {\n    name: 'Box semi-transparent front',\n    component: (\n      <Box>\n        <div\n          style={{\n            background: 'linear-gradient(to bottom, blue, orange)',\n            opacity: 1,\n          }}\n        >\n          HELLO\n        </div>\n      </Box>\n    ),\n  },\n  {\n    name: 'The “transparent” theme',\n    component: <Box boxThemeKey=\"transparent\">HELLO</Box>,\n  },\n  {\n    name: 'The “yellowOrange” theme',\n    component: <Box boxThemeKey=\"yellowOrange\">HELLO</Box>,\n  },\n  {\n    name: 'LabeledBox',\n    component: <LabeledBox {...labeled}>{hello()}</LabeledBox>,\n  },\n  {\n    name: 'Grayscale LabeledBox',\n    component: (\n      <LabeledBox zLevel={1} boxThemeKey=\"grayscale\" {...labeled}>\n        {hello()}\n      </LabeledBox>\n    ),\n  },\n  {\n    name: 'Stacked LabeledBox',\n    component: (\n      <LabeledBox {...labeled}>\n        <LabeledBox zLevel={1} {...labeled}>\n          {hello()}\n        </LabeledBox>\n      </LabeledBox>\n    ),\n  },\n  { name: 'LabeledTextBox', component: <LabeledTextBox {...labeledText} /> },\n  {\n    name: 'opacity = 0.7',\n    component: <LabeledTextBox {...labeledText} zLevel={1} />,\n  },\n  {\n    name: '8 Level Tower',\n    showSource: false,\n    component: (() => {\n      const max = 8;\n      const Layer: FC<{ levels: number }> = ({ levels }) =>\n        levels === 1 ? (\n          <LabeledTextBox zLevel={1} labelText={`${max}`} text={`${max}`} />\n        ) : (\n          <LabeledBox text={`${max - levels + 1}`} zLevel={1}>\n            <VFlex gap=\"1px\">\n              <Layer levels={levels - 1} />\n            </VFlex>\n          </LabeledBox>\n        );\n\n      return <Layer levels={max} />;\n    })(),\n  },\n  {\n    name: 'Cantor Set',\n    showSource: false,\n    component: (() => {\n      const levels = 5;\n\n      type Wide = FC<{ width: number; borderWidth?: number }>;\n\n      const blockStyles = [fontSizePx(5), css.centerText],\n        frontClassName = style(bgColor('transparent'), heightPx(20));\n\n      const Block: Wide = ({ width, borderWidth = 1 }) => (\n        <Box\n          opacity={1}\n          boxThemeKey=\"grayscale\"\n          {...{ borderWidth }}\n          borderColor=\"grey\"\n          styles={[...blockStyles, widthPx(width)]}\n          addFrontBg\n        >\n          <div className={frontClassName}></div>\n        </Box>\n      );\n\n      const Space: Wide = ({ width }) => (\n        <div className={style(widthPx(width))} />\n      );\n\n      const Branch: Wide = ({ width, borderWidth }) => (\n        <VFlex noGap>\n          <Block {...{ width, borderWidth }} />\n          <Layer {...{ width }} />\n        </VFlex>\n      );\n\n      const Layer: Wide = ({ width: totalWidth }) => {\n        const width = totalWidth / 3;\n        if (width <= 1 / 3) return <></>;\n\n        const borderWidth = width <= 1 ? 0.1 : width <= 3 ? 0.5 : 1;\n\n        return (\n          <HFlex noGap>\n            <Branch {...{ width, borderWidth }} />\n            <Space {...{ width }} />\n            <Branch {...{ width, borderWidth }} />\n          </HFlex>\n        );\n      };\n\n      return (\n        <VFlex noGap z={px(24)} is3D>\n          <Block width={3 ** levels} />\n          <Layer width={3 ** levels} />\n        </VFlex>\n      );\n    })(),\n  },\n];\n\n/*\n    name: 'Is 6 levels enough?',\n-    component: (\n\n-                      <LabeledBox text=\"Level 5\" zLevel={1} opacity={0.4}>\n-                        <VFlex>\n-                          <LabeledTextBox\n-                            zLevel={1}\n-                            {...labeledText}\n-                            opacity={0.3}\n-                          />\n-                        </VFlex>\n-                      </LabeledBox>\n\n-      <LabeledBox text=\"Level 1\" zLevel={1}>\n-        <VFlex>\n-          <LabeledBox text=\"Level 2\" zLevel={1} opacity={0.7}>\n-            <VFlex>\n-              <LabeledBox text=\"Level 3\" zLevel={1} opacity={0.6}>\n-                <VFlex>\n-                  <LabeledBox text=\"Level 4\" zLevel={1} opacity={0.5}>\n-                    <VFlex>\n-                      <LabeledBox text=\"Level 5\" zLevel={1} opacity={0.4}>\n-                        <VFlex>\n-                          <LabeledTextBox\n-                            zLevel={1}\n-                            {...labeledText}\n-                            opacity={0.3}\n-                          />\n-                        </VFlex>\n-                      </LabeledBox>\n-                    </VFlex>\n-                  </LabeledBox>\n-                </VFlex>\n-              </LabeledBox>\n\n\n*/\n","export const LineStyles = [\n  'dashed',\n  'dotted',\n  'double',\n  'groove',\n  'hidden',\n  'inset',\n  'none',\n  'outset',\n  'ridge',\n  'solid',\n] as const;\n\nexport const BorderDirs = ['top', 'bottom', 'left', 'right'] as const;\n\n/** Shortcuts for some subsets from the 4 sides of a rectangular shape */\nexport const BorderEdges = {\n  none: [],\n  all: ['top', 'bottom', 'left', 'right'],\n  top: ['top'],\n  right: ['right'],\n  bottom: ['bottom'],\n  left: ['left'],\n  leftRight: ['left', 'right'],\n  noBottom: ['top', 'left', 'right'],\n  noTop: ['bottom', 'left', 'right'],\n  topBottom: ['bottom', 'top'],\n} as const;\n","import { without } from 'fp-ts-std/Array';\nimport { reject } from 'fp-ts-std/Record';\nimport { pipe, tupled } from 'fp-ts/lib/function';\nimport { Eq as StringEq } from 'fp-ts/string';\nimport { ToRequired } from 'src/util/types';\nimport { U } from 'ts-toolbelt';\n\n/** Pick a subset of an object by keys.\n```\nconst picked: { a: number; b: string } = picks(\n  'a',\n  'b',\n)({ a: 1, b: 'foo', c: /re/ });\n```\n*/\n\nexport const picks = <KS extends readonly PropertyKey[]>(...keys: KS) => <\n  T extends { [K in KS[number]]: T[K] }\n>(\n  o: T,\n): Pick<T, KS[number]> => {\n  const res = {} as Pick<T, KS[number]>;\n  keys.forEach((key: KS[number]) => {\n    res[key] = o[key];\n  });\n  return res;\n};\n\nexport const mergeObjects = <T>(...objects: readonly T[]): T =>\n  Object.assign({}, ...objects);\n\n/** Tupled version of `mergeObject` */\ntype MergeObjectsT = <T>(objects: readonly T[]) => T;\nexport const mergeObjectsT: MergeObjectsT = tupled(mergeObjects);\n\nexport const filterNonValues = <T>(\n  unfiltered: Record<string, T>,\n): Record<string, T> =>\n  pipe(\n    unfiltered,\n    reject(x => x === undefined),\n  );\n\nexport const mergeDefined = <T>(first: T) => (...rest: Partial<T>[]): T =>\n  mergeObjects(...[first, ...rest].map(filterNonValues)) as T;\n\ntype Split<S extends T, T> = [Pick<S, keyof T>, Omit<S, keyof T>];\nexport const split = <K extends string>(keys: readonly K[]) => <\n  T extends Partial<{ [P in K]: T[P] }>\n>(\n  o: T,\n): [Pick<T, K>, Omit<T, K>] => {\n  const withKeys: Pick<T, K> = pipe(o, picks(...keys.filter(key => key in o))),\n    restKeys = without(StringEq)([...keys])(Object.keys(o)) as (keyof Omit<\n      T,\n      K\n    >)[],\n    withRestKeys = pipe(o, picks(...restKeys));\n  return [withKeys, withRestKeys];\n};\n\n/** Tuple of keys of `T`\n *\n * Discards the value types of `T`. Example:\n * ```\n * type Obj = {x: string;y: string;z: number};\n * type Keys = KeyList<Obj>; // ['x', 'y', 'z']\n * ```\n */\nexport type KeyList<T> = U.ListOf<keyof T> & (keyof T)[];\n\nexport interface TypedKeys {\n  <T>(o: T): KeyList<T>;\n}\n\n/**\n * Like `Object.keys`, but returns an ordered list of the key union members\n * instead of `string[]`. Useful only when `T` is an exact type.\n * ```\n * const keys: ['x', 'y', 'z'] = typedKeys({x: 1, y: 'foo', z: [3, 4]});\n * ```\n */\nexport const typedKeys: TypedKeys = o =>\n  (Object.keys(o) as unknown) as KeyList<typeof o>;\n\n/** Spread a total value of type `T` into some useful utilities\n *\n * Products 4 elements from a default member of `T`.\n *\n * @param defaultDef a default member of `T`\n * @returns 4-tuple of:\n * 1. A function that splits into two disjoint sets, any union with `T` into a\n * pair of `T`, and an object with all entries left over after picking out the\n * keys of `T`\n * 2. A function that merges defaults into missing/undefined entries of the\n * input. Results in a total `T`\n * 3. The default `T`. Useful when building defaults of composites of `T`\n * 4. The tuple of `T` keys, of the type `KeyList<T>`. Useful when building key\n * lists for composites of `T`\n */\nexport const defaultHelpers = <T>(\n  defaultDef: Required<T>,\n): [\n  <S extends T>(o: S) => Split<S, T>,\n  ToRequired<T>,\n  Required<T>,\n  KeyList<T>,\n] => [\n  pipe(defaultDef, typedKeys, split),\n  mergeDefined(defaultDef),\n  defaultDef,\n  typedKeys(defaultDef),\n];\n\nexport const pluck = <K extends string>(k: K) => <T extends { [P in K]: T[P] }>(\n  o: T,\n): T[K] => o[k];\n\n/**\n * Curried create singleton record, value first\n *\n * @param v The value\n * @param k The key\n * @returns `{[k]: v}`\n */\nexport const unaryObject = <V>(v: V) => <K extends string>(k: K) =>\n  ({ [k]: v } as Record<K, V>);\n","import { multiply } from 'fp-ts-std/Number';\nimport { flow, pipe } from 'fp-ts/function';\nimport * as RA from 'fp-ts/ReadonlyArray';\nimport { singleton } from 'fp-ts/Record';\nimport { css } from 'src/css/lib';\nimport { Style, StyleKey } from 'src/css/types';\nimport { emRecord, pxRecord } from 'src/css/util';\nimport { Color, Gap } from 'src/css/valueTypes';\nimport { Angle3, Point, ThreeDAxis } from 'src/geometry';\nimport { px } from './util';\n\nconst unaryStyle = <V>() => <K extends StyleKey>(k: K) => (v: V): Style =>\n    singleton(k, v),\n  pxStyle = <K extends StyleKey>(k: K) => flow(px, unaryStyle<string>()(k));\n\nexport const translate = (point: Point): string =>\n    Object.entries(point)\n      .map(([k, v]) => (v !== undefined ? `translate${k}(${v})` : ''))\n      .join(' '),\n  rotate = (angle: Angle3): string =>\n    Object.entries(angle)\n      .map(([k, v]) => (v !== undefined ? `rotate${k}(${v}deg)` : ''))\n      .join(' ');\n\nexport const rotateX = (angle: number) => rotate({ x: angle }),\n  rotateY = (angle: number) => rotate({ y: angle }),\n  rotateZ = (angle: number) => rotate({ z: angle }),\n  rotateBy = (axis: ThreeDAxis) => (angle: number) => rotate({ [axis]: angle }),\n  scaleBy = (s: number) => `scale(${s})`;\n\nexport const transform = (...parts: string[]): { transform: string } => ({\n  transform: parts.join(' '),\n});\n\nexport const hFlexGapPx = (gap: Gap): Style => ({ gap, ...css.hFlex }),\n  vFlexGapPx = (gap: Gap): Style => ({ gap, ...css.vFlex });\n\nexport const hPadding = (pad: string | 0) =>\n    ({ paddingLeft: pad, paddingRight: pad } as const),\n  margin = unaryStyle<string | 0>()('margin'),\n  padding = unaryStyle<string | 0>()('padding');\n\nexport const sizePx = (width: number, height: number): Style =>\n  pxRecord({ width, height });\n\nexport const [widthPx, heightPx] = pipe(\n  ['width', 'height'] as const,\n  RA.map(pxStyle),\n);\n\nexport const [topLeftBorderRadius, topRightBorderRadius] = [\n  pxStyle('borderTopLeftRadius'),\n  pxStyle('borderTopRightRadius'),\n];\n\nexport const bgColor = unaryStyle<Color>()('backgroundColor'),\n  fgColor = unaryStyle<Color>()('color'),\n  emLineHeight = (h: number) => emRecord({ lineHeight: h, height: h });\n\nexport const fontSizePx = pxStyle('fontSize');\n\nexport const animation = (animationName: string) => (\n  periodSec: number,\n): Style => ({\n  animationName,\n  animationDuration: `${periodSec}s`,\n  animationIterationCount: 'infinite',\n  animationTimingFunction: 'linear',\n});\n\nexport const add100px = (d: number) => `calc(100% + ${px(d)})`;\nexport const sub100px = flow(multiply(-1), add100px);\n","import { FC, ReactElement } from 'react';\nimport reactElementToJSXString from 'react-element-to-jsx-string';\nimport { Prism as SyntaxHighlighter } from 'react-syntax-highlighter';\nimport { ghcolors as colors } from 'react-syntax-highlighter/dist/esm/styles/prism';\nimport { Styled } from 'src/component/Styled';\nimport { HFlex, Labeled } from 'src/component/TwoD';\nimport { bgColor, cssOf } from 'src/css';\nimport { style } from 'typestyle';\n\nconst decode = reactElementToJSXString;\n\ninterface Source extends Styled {\n  idx: number;\n  component: ReactElement;\n  name?: string;\n  showSource?: boolean;\n}\n\nconst parentStyles = [cssOf('h100', 'alignBaseline'), bgColor('#f0f0f0ac')],\n  sourceClassName = style({ fontSize: '9px' });\n\nexport const Source: FC<{ component: ReactElement }> = ({ component }) => (\n  <SyntaxHighlighter language=\"tsx\" style={colors}>\n    {decode(component, { filterProps: ['key'] })}\n  </SyntaxHighlighter>\n);\n\nexport const ComponentSource: FC<Source> = ({\n  idx,\n  component,\n  name = 'Anonymous',\n  showSource = true,\n}) => (\n  <Labeled text={`${idx + 1}. ${name}`}>\n    <HFlex styles={parentStyles} borderEdges=\"all\">\n      {component}\n      {showSource && (\n        <div className={sourceClassName}>\n          <Source {...{ component }} />\n        </div>\n      )}\n    </HFlex>\n  </Labeled>\n);\n","import { FC } from 'react';\nimport { Styled } from 'src/component/Styled';\nimport { gridBg, GridConfig, OmitBackground } from 'src/css';\nimport { style } from 'typestyle';\n\nexport type Scene = Styled<OmitBackground> & Partial<GridConfig>;\n\n/** A container with an optional grid background */\nexport const Scene: FC<Scene> = ({ children, styles = [], ...grid }) => (\n  <div className={style(gridBg(grid), ...styles)}>{children}</div>\n);\n","import { flow, pipe } from 'fp-ts/lib/function';\nimport { css, rotate, Style } from 'src/css';\nimport { Angle3, ZeroAngle3 } from 'src/geometry';\nimport { mergeDefined } from 'src/util';\n\ninterface Camera {\n  angle?: Angle3;\n}\n\ntype Cameras = typeof cameras;\n\nconst cameras = {\n  front: {},\n  back: { angle: { y: -180 } },\n  top: { angle: { x: -90 } },\n  bottom: { angle: { x: 90 } },\n  left: { angle: { y: 90 } },\n  right: { angle: { y: -90 } },\n\n  iso: { angle: { x: -30, y: 30 } },\n  invIso: { angle: { x: 30, y: -30 } },\n  iso45: { angle: { x: -15, y: 45 } },\n  invIso45: { angle: { x: 15, y: -45 } },\n\n  frontTopLeft: { angle: { x: -45, y: 45 } },\n  frontTopRight: { angle: { x: -45, y: -45 } },\n  frontBottomLeft: { angle: { x: 45, y: 45 } },\n  frontBottomRight: { angle: { x: 45, y: -45 } },\n} as const;\n\nconst camera = (key: CameraKey): Camera => cameras[key],\n  cameraAngle = (camera?: Camera): Angle3 =>\n    mergeDefined(ZeroAngle3)(camera?.angle ?? {});\n\nexport type CameraKey = keyof Cameras;\n\nexport const cameraKeyAngle = flow(camera, cameraAngle),\n  cameraStyle = (key: CameraKey): Style => ({\n    ...css.centerOrigin,\n    transform: pipe(key, cameraKeyAngle, rotate),\n  });\n","import { flow, pipe } from 'fp-ts/lib/function';\nimport { CameraKey, cameraKeyAngle } from 'src/component/Viewport/camera';\nimport { rotate } from 'src/css';\nimport { Angle3, invDeg } from 'src/geometry';\nimport { keyframes } from 'typestyle';\n\nexport type Orbit = typeof Orbits[number];\nexport type OrbitAnimation = (cameraKey: CameraKey) => (orbit: Orbit) => string;\n\ntype OrthoOrbit = keyof Angle3;\n\nexport const OrthoOrbits: OrthoOrbit[] = ['x', 'y', 'z'],\n  Orbits = [...OrthoOrbits, 'xy', 'xz', 'yz', 'xyz'] as const;\n\nconst invAngle3 = ({ x, y, z }: Angle3) => (orbit: Orbit): Angle3 => {\n  const inverseOrbitKey = (\n    key: 'x' | 'y' | 'z',\n    value: number | undefined,\n  ) => ({\n    [key]:\n      value === undefined ? 0 : orbit.includes(key) ? invDeg(value) : value,\n  });\n\n  return {\n    ...inverseOrbitKey('x', x),\n    ...inverseOrbitKey('y', y),\n    ...inverseOrbitKey('z', z),\n  };\n};\n\nconst orbitFrames = (from: Angle3) => (orbit: Orbit): string =>\n  keyframes({\n    from: { transform: rotate(from) },\n    to: { transform: pipe(orbit, invAngle3(from), rotate) },\n  });\n\n/**\n * Generate an animation name from a camera angle and an orbit\n *\n * @param from a name of a camera angle\n * @returns a function from `Orbit` to the string animation name generated\n *\n * Example:\n * ```\n * import { animation, orbitAnimation } from 'projected-components';\n *\n * const camera    = 'front';                       // front camera angle\n * const orbit     = 'yz';                          // rotate on YZ axes\n * const periodSec = 2;                             // 1 turn / 2 seconds\n * const keyframes = orbitAnimation(camera)(orbit);\n * const style     = animation(keyframes)(periodSec)\n * ```\n */\nexport const orbitAnimation: OrbitAnimation = flow(cameraKeyAngle, orbitFrames);\n","import { pipe } from 'fp-ts/lib/function';\nimport { FC } from 'react';\nimport { Scene } from 'src/component/Scene';\nimport { Styled } from 'src/component/Styled';\nimport { CameraKey, cameraStyle } from 'src/component/Viewport/camera';\nimport { Orbit, orbitAnimation } from 'src/component/Viewport/orbit';\nimport {\n  animation,\n  cssOf,\n  defaultClass,\n  GridConfig,\n  scaleBy,\n  transform,\n} from 'src/css';\nimport { style } from 'typestyle';\n\nexport * from 'src/component/Viewport/camera';\nexport * from 'src/component/Viewport/orbit';\n\nexport interface Viewport extends Partial<GridConfig>, Styled {\n  camera?: CameraKey;\n  orbit?: Orbit;\n  scale?: number;\n  isOrbiting?: boolean;\n  reverse?: boolean;\n  periodSec?: number;\n  perspective?: string;\n}\n\nconst sceneCss = cssOf('threeD'),\n  scaleDivCss = defaultClass('leftTopOrigin');\n\n/**\n * A 3D scene and a camera for looking at it\n *\n * Add 3D components to the `Viewport` and they will be placed in the scene,\n * on an optional background grid, and projected as 2D at the given scale and\n * perspective. Set `isOrbiting` and the camera will rotate on the given axis\n * at the given speed.\n *\n * Viewport:\n * @param camera a camera key of the `CameraKey` type. Defines a 3D angle for\n * the initial camera placement. The isometric angle is default\n * @orbit an orbit for the camera rotation. Ignored unless `isOrbiting`. The\n * orbit is a selection of 1, 2 or 3 axes. E.g.: An orbit of 'xy' will rotate\n * the camera, at equal angular velocity, on both 𝔁 and 𝔂 axes\n * simultaneously. Default is `y`\n * @periodSec the camera completes one turn in `periodSec` seconds. Default is\n * 10 seconds\n * @isOrbiting if true, then the `orbit` and `periodSec` are applied - the\n * camera is rotated around the orbit in a constant rate. Default is `false`\n * @reverse if true, `animation-direction` is reversed. Default is `false`\n * @perspective perspective distance for the CSS `perspective` value. Default\n * is `120em`\n *\n * Scene background grid:\n * @param majorStep\n * @param color\n * @param bgColor\n * @param strokeWidth\n *\n */\nexport const Viewport: FC<Viewport> = ({\n  camera = 'iso' as CameraKey,\n  orbit = 'y',\n  scale = 1,\n  isOrbiting = false,\n  reverse = false,\n  periodSec = 10,\n  perspective = '120em',\n  styles = [],\n  children,\n  ...props\n}) => (\n  <div className={style(...styles)}>\n    <div\n      className={scaleDivCss(pipe(scale, scaleBy, transform), {\n        perspective,\n      })}\n    >\n      <Scene\n        {...props}\n        styles={[\n          sceneCss,\n          cameraStyle(camera),\n          cssOf(isOrbiting ? 'play' : 'pause'),\n          pipe(orbit, orbitAnimation(camera), animation)(periodSec),\n          { animationDirection: reverse ? 'reverse' : 'normal' },\n        ]}\n      >\n        {children}\n      </Scene>\n    </div>\n  </div>\n);\n","import { FC } from 'react';\nimport { demos } from 'src/component/Demos';\nimport { ComponentSource } from 'src/component/Source';\nimport { HFlex } from 'src/component/TwoD';\nimport { Viewport } from 'src/component/Viewport';\nimport { css } from 'src/css';\n\nexport const App: FC = () => (\n  <div style={(css.autoOverflow, css.wh100)}>\n    <Viewport\n      scale={1}\n      camera=\"iso\"\n      orbit=\"y\"\n      strokeWidth={2}\n      periodSec={20}\n      perspective=\"150em\"\n      styles={[{ padding: '1em' }]}\n      isOrbiting\n    >\n      <HFlex wrap styles={[css.stretch]}>\n        {demos.map(({ name, showSource, component }, idx) => (\n          <ComponentSource\n            key={idx}\n            {...{ showSource, idx, name, component }}\n          />\n        ))}\n      </HFlex>\n    </Viewport>\n  </div>\n);\n","import { flow } from 'fp-ts/lib/function';\nimport * as RE from 'fp-ts/ReadonlyRecord';\nimport { BorderEdges } from 'src/css/border/constants';\nimport { BorderDef, BorderEdge, EdgeDef } from 'src/css/border/types';\nimport { Style } from 'src/css/types';\nimport { px, ucFirst } from 'src/css/util';\nimport { defaultHelpers } from 'src/util';\n\nexport * from 'src/css/border/constants';\nexport * from 'src/css/border/types';\n\nexport const [\n    splitEdgeDef,\n    withDefaultEdgeDef,\n    defaultEdgeDef,\n  ] = defaultHelpers<EdgeDef>({\n    borderWidth: 1,\n    borderStyle: 'solid',\n    borderColor: 'black',\n  }),\n  [\n    splitBorderDef,\n    withDefaultBorderDef,\n    defaultBorderDef,\n  ] = defaultHelpers<BorderDef>({ ...defaultEdgeDef, borderEdges: 'none' });\n\n/**\n * True if the definition will render a border that will take up layout space.\n * A `transparent` border with `borderEdges > 0` and `borderWidth > 0` will\n * return true because this border still takes up layout space.\n **/\nexport const hasBorder = (borderDef: BorderDef = {}): boolean =>\n  !RE.isEmpty(borderDef) &&\n  borderDef.borderEdges !== 'none' &&\n  borderDef.borderWidth !== 0;\n\n/** Add border edges to an `EdgeDef` making a `BorderDef` */\nexport const addBorderEdges = (edgeDef: EdgeDef) => (\n    borderEdges: BorderEdge = 'all',\n  ): BorderDef & { borderEdges: BorderEdge } => ({\n    ...edgeDef,\n    borderEdges,\n  }),\n  addAllBorderEdges = (edgeDef: EdgeDef) => addBorderEdges(edgeDef)('all');\n\n/**\n * Convert a border definition into a style object.\n *\n * @param borderDef The border definition: `borderWidth`, `borderStyle`,\n * `borderColor`, and `borderEdges`.\n * @returns Style object\n */\nexport const borderCss = (borderDef: BorderDef = {}): Style => {\n  if (!hasBorder(borderDef)) return {};\n\n  const {\n    borderWidth,\n    borderStyle,\n    borderColor,\n    borderEdges,\n  } = withDefaultBorderDef(borderDef);\n\n  const edgeList: readonly BorderEdge[] = BorderEdges[borderEdges];\n\n  return Object.fromEntries(\n    edgeList.map(edge => [\n      `border${ucFirst(edge)}`,\n      [px(borderWidth), borderStyle, borderColor].join(' '),\n    ]),\n  );\n};\n\n/**\n * Convert an edge definition into a style object. Same edge is rendered for\n * each of the 4 border sides.\n *\n * @param edgeDef `borderWidth`, `borderStyle` and\n * `borderColor`\n * @returns Style object\n */\nexport const allBordersCss = flow(addAllBorderEdges, borderCss);\n","import { deg, repeatingLinearGradient } from 'csx';\nimport { CsxColorStop } from 'csx/lib/types';\nimport { bgColor as backgroundColor } from 'src/css/builders';\nimport { Style } from 'src/css/types';\nimport { px } from 'src/css/util';\nimport { Color } from 'src/css/valueTypes';\nimport { mergeDefined, square } from 'src/util';\n\nexport interface GridConfig {\n  majorStep: number;\n  color: Color;\n  bgColor: Color;\n  strokeWidth: number;\n}\n\nconst defaultConfig: GridConfig = {\n  majorStep: 24,\n  color: '#ff000026',\n  bgColor: 'transparent',\n  strokeWidth: 0,\n};\n\nconst colorStop = (color: Color, strokeWidth: number): CsxColorStop => [\n    color,\n    px(strokeWidth),\n  ],\n  parallelLines = (majorStep: number, color: Color, strokeWidth: number) => (\n    angle: number,\n    bgColor: Color,\n  ): string => {\n    const halfStroke = strokeWidth / 2,\n      bottom = majorStep - halfStroke;\n\n    return repeatingLinearGradient(\n      deg(angle),\n      colorStop(color, 0),\n      colorStop(color, halfStroke),\n      colorStop(bgColor, halfStroke),\n      colorStop(bgColor, bottom),\n      colorStop(color, bottom),\n      colorStop(color, majorStep),\n    );\n  };\n\n/**\n * A background grid for debugging layout\n *\n * Given a partial `GridConfig`, returns the `background` CSS value required\n * to render the grid as a component background. Grids shown at dev time help\n * testing.\n *\n * `background` value returned depends on the given `GridConfig`:\n *\n * ```\n * ┌──────────────────────────────┐┌───────────────────┐\n * │             INPUT            ││      STYLE        │\n * ├─────────┬───────────┬────────┤├───────────────────┤\n * │majorStep│strokeWidth│bgColor ││                   │\n * ├─────────┼───────────┼────────┤│                   │\n * │    == 0 │       any │!defined││empty style        │\n * ├─────────┼───────────┼────────┤├───────────────────┤\n * │     any │      == 0 │ defined││flat bg color      │\n * ├─────────┼───────────┼────────┤├───────────────────┤\n * │    != 0 │      != 0 │!defined││grid pattern, no bg│\n * ├─────────┼───────────┼────────┤├───────────────────┤\n * │    != 0 │      != 0 │ defined││grid pattern + bg  │\n * └─────────┴───────────┴────────┘└───────────────────┘\n * ```\n *\n * Undefined grid config values are replaced with defaults:\n * ```\n * {\n *    majorStep: 24,\n *    color: '#ff000026',\n *    bgColor: 'transparent',\n *    strokeWidth: 0,\n * }\n * ```\n * Examples:\n *\n * 1. `gridBg()`, `gridBg({strokeWidth: 0, majorStep: 100})`,\n * `gridBg({majorStep: 0, strokeWidth: 1})` - no grid nor background\n * 1. `gridBg({bgColor: 'red'})`, `gridBg({strokeWidth: 0, bgColor: 'red'})` -\n * flat red background\n * 1. `gridBg({strokeWidth: 1})` - grid with no background, using default\n * `majorStep`\n * 1. `gridBg({strokeWidth: 2, majorStep: 5, bgColor: 'red', color: 'blue'})` -\n * red background with blue colored 2px wide grid, gridlines every 5px\n *\n **/\nexport const gridBg = (config: Partial<GridConfig> = {}): Style => {\n  const { majorStep, color, bgColor, strokeWidth } = mergeDefined(\n    defaultConfig,\n  )(config);\n\n  if (majorStep === 0 || strokeWidth === 0)\n    return bgColor !== undefined ? backgroundColor(bgColor) : {};\n\n  const lines = parallelLines(majorStep, color, strokeWidth),\n    background = [lines(0, 'transparent'), lines(90, bgColor)].join(',');\n\n  const halfSize = square(px(majorStep)).join(' '),\n    backgroundSize = square(halfSize).join(',');\n\n  return { background, backgroundSize, backgroundAttachment: 'local' };\n};\n"],"sourceRoot":""}